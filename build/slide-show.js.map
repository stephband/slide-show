{
  "version": 3,
  "sources": ["https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/cache.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/curry.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/exec.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/capture.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/id.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/overload.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/noop.js", "https://cdn.jsdelivr.net/gh/stephband/dom@master/modules/assign.js", "https://cdn.jsdelivr.net/gh/stephband/dom@master/modules/create.js", "https://cdn.jsdelivr.net/gh/stephband/dom@master/modules/element/to-load-promise.js", "https://cdn.jsdelivr.net/gh/stephband/dom@master/modules/element/to-prefetch-promise.js", "https://cdn.jsdelivr.net/gh/stephband/dom@master/modules/element/internals.js", "https://cdn.jsdelivr.net/gh/stephband/dom@master/modules/element.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/equals.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/get.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/arg.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/self.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/nothing.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/signal.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/data.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/is-iterable.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/to-type.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/stream/stream.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/stream/buffer-stream.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/stream/promise-stream.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/stream/combine-stream.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/stream/merge-stream.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/stream/clock-stream.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/stream/throttle-stream.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/stream/signal-stream.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/stream.js", "https://cdn.jsdelivr.net/gh/stephband/dom@master/modules/events.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/parse-value.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/to-rad.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/parse-angle.js", "https://cdn.jsdelivr.net/gh/stephband/dom@master/modules/style.js", "https://cdn.jsdelivr.net/gh/stephband/dom@master/modules/parse-length.js", "https://cdn.jsdelivr.net/gh/stephband/dom@master/modules/gestures.js", "https://cdn.jsdelivr.net/gh/stephband/dom@master/modules/is-primary-button.js", "https://cdn.jsdelivr.net/gh/stephband/dom@master/modules/rect.js", "https://cdn.jsdelivr.net/gh/stephband/dom@master/modules/trigger.js", "../modules/consts.js", "https://cdn.jsdelivr.net/gh/stephband/dom@master/modules/is-firefox.js", "../modules/active.js", "../modules/swipes.js", "../modules/scrollends.js", "../modules/lifecycle.js", "https://cdn.jsdelivr.net/gh/stephband/dom@master/modules/element/create-boolean.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/remove.js", "https://cdn.jsdelivr.net/gh/stephband/dom@master/modules/element/token-list.js", "https://cdn.jsdelivr.net/gh/stephband/dom@master/modules/element/update-token-list.js", "https://cdn.jsdelivr.net/gh/stephband/dom@master/modules/element/create-token-list.js", "../modules/autoplay.js", "../modules/loop.js", "../modules/navigation.js", "https://cdn.jsdelivr.net/gh/stephband/dom@master/modules/delegate.js", "../modules/pagination.js", "../modules/fullscreen.js", "https://cdn.jsdelivr.net/gh/stephband/dom@master/modules/fullscreen.js", "../modules/properties.js", "../module.js"],
  "sourcesContent": ["/**\ncache(fn)\nReturns a function that caches the output values of `fn(input)` against input\nvalues in a map, such that for each input value `fn` is only ever called once.\n*/\n\nlet warned;\n\nexport default function cacheByObject(fn) {\n    var map = new Map();\n\n    return function cache(object) {\n        if (window.DEBUG && !warned && object === undefined) {\n            warned = true;\n            console.warn('cache() called with undefined. Not illegal, but potentially bad.');\n        }\n\n        if (window.DEBUG && arguments.length > 1) {\n            console.warn('cache() called with ' + arguments.length + ' arguments. Accepts exactly 1.');\n        }\n\n        if (map.has(object)) {\n            return map.get(object);\n        }\n\n        var value = fn(object);\n        map.set(object, value);\n        return value;\n    };\n}\n", "/**\ncurry(fn [, muteable, arity])\nReturns a function that wraps `fn` and makes it partially applicable.\n*/\n\nimport cache from './cache.js';\n\nconst A     = Array.prototype;\n\nfunction applyFn(fn, args) {\n    return typeof fn === 'function' ? fn.apply(null, args) : fn ;\n}\n\nfunction curry(fn, muteable, arity) {\n    arity = arity || fn.length;\n\n    var memo = arity === 1 ?\n        // Don't cache if `muteable` flag is true\n        muteable ? fn : cache(fn) :\n\n        // It's ok to always cache intermediate memos, though\n        cache(function(object) {\n            return curry(function() {\n                var args = [object];\n                args.push.apply(args, arguments);\n                return fn.apply(null, args);\n            }, muteable, arity - 1) ;\n        }) ;\n\n    return function partial(object) {\n        return arguments.length === 0 ?\n            partial :\n        arguments.length === 1 ?\n            memo(object) :\n        arguments.length >= arity ?\n            fn.apply(null, arguments) :\n        // This is bad, I think. We don't want [[fn],[fn]].map(get(0)) to be firing the fns\n        //arguments.length > arity ?\n        //    applyFn(fn.apply(null, A.splice.call(arguments, 0, arity)), arguments) :\n        applyFn(memo(object), A.slice.call(arguments, 1)) ;\n    };\n}\n\n//function curry(fn, muteable, arity) {\n//    arity = arity || fn.length;\n//    return function curried() {\n//        return arguments.length >= arity ?\n//            fn.apply(null, arguments) :\n//            curried.bind(null, ...arguments) ;\n//    };\n//}\n\nif (window.DEBUG) {\n    const _curry = curry;\n\n    // Feature test\n\tconst isFunctionLengthDefineable = (function() {\n\t\tvar fn = function() {};\n\n\t\ttry {\n\t\t\t// Can't do this on Safari - length non configurable :(\n\t\t\tObject.defineProperty(fn, 'length', { value: 2 });\n\t\t}\n\t\tcatch(e) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn fn.length === 2;\n\t})();\n\n    const setFunctionProperties = function setFunctionProperties(text, parity, fn1, fn2) {\n        // Make the string representation of fn2 display parameters of fn1\n        fn2.toString = function() {\n            return /function\\s*[\\w\\d]*\\s*\\([,\\w\\d\\s]*\\)/.exec(fn1.toString()) + ' { [' + text + '] }';\n        };\n\n        // Where possible, define length so that curried functions show how\n        // many arguments they are yet expecting\n        if (isFunctionLengthDefineable) {\n            Object.defineProperty(fn2, 'length', { value: parity });\n        }\n\n        return fn2;\n    };\n\n    // Make curried functions log a pretty version of their partials\n    curry = function curry(fn, muteable, arity) {\n        arity  = arity || fn.length;\n        return setFunctionProperties('curried', arity, fn, _curry(fn, muteable, arity));\n    };\n}\n\n\nexport default curry;\n", "\n/**\nexec(regex, fn, string)\nCalls `fn` with the result of `regex.exec(string)` if that result is not null,\nand returns the resulting value.\n**/\n\nimport curry from './curry.js';\n\nexport function exec(regex, fn, string) {\n    let data;\n\n    // If string looks like a regex result, get rest of string\n    // from latest index\n    if (typeof string !== 'string' && string.input !== undefined && string.index !== undefined) {\n        data = string;\n        string = data.input.slice(\n            string.index\n            + string[0].length\n            + (string.consumed || 0)\n        );\n    }\n\n    // Look for tokens\n    const tokens = regex.exec(string);\n    if (!tokens) { return; }\n\n    const output = fn(tokens);\n\n    // If we have a parent tokens object update its consumed count\n    if (data) {\n        data.consumed = (data.consumed || 0)\n            + tokens.index\n            + tokens[0].length\n            + (tokens.consumed || 0) ;\n    }\n\n    return output;\n}\n\nexport default curry(exec, true);\n", "\nimport curry from './curry.js';\nimport { exec } from './exec.js';\n\nfunction error(regex, reducers, string) {\n    if (string.input !== undefined && string.index !== undefined) {\n        string = string.input;\n    }\n\n    throw new Error('Cannot parse string \"' + (string.length > 128 ? string.length.slice(0, 128) + 'â€¦' : string) + '\"');\n}\n\nfunction reduce(reducers, acc, tokens) {\n    let n = -1;\n\n    while (++n < tokens.length) {\n        acc = (tokens[n] !== undefined && reducers[n]) ? reducers[n](acc, tokens) : acc ;\n    }\n\n    // Call the optional done fn\n    return reducers.done ? reducers.done(acc, tokens) :\n        // Support the old .close() name\n        reducers.close ? reducers.close(acc, tokens) :\n        // Return the result\n        acc ;\n}\n\n/**\ncapture(regex, reducers, accumulator, string)\nParse `string` with `regex`, calling functions in `reducers` to modify\nand return `accumulator`.\n\nReducers is an object of functions keyed by the index of their capturing\ngroup in the regexp result (`0` corresponding to the entire regex match,\nthe first capturing group being at index `1`). Reducer functions are\ncalled in capture order for all capturing groups that captured something.\nReducers may also define the function 'done', which is called at the end\nof every capture. All reducer functions are passed the paremeters\n`(accumulator, tokens)`, where `tokens` is the regexp result, and are expected\nto return a value that is passed as an accumulator to the next reducer function.\n\nReducers may also define a function `'catch'`, which is called when a match\nhas not been made (where `'catch'` is not defined an error is thrown).\n\n```js\nconst parseValue = capture(/^\\s*(-?\\d*\\.?\\d+)(\\w+)?\\s*$/, {\n    // Create a new accumulator object each call\n    0: () => ({}),\n\n    1: (acc, tokens) => {\n        acc.number = parseFloat(tokens[1]);\n        return acc;\n    },\n\n    2: (acc, tokens) => {\n        acc.unit = tokens[2];\n        return acc;\n    }\n}, null);\n\nconst value = parseValue('36rem');    // { number: 36, unit: 'rem' }\n```\n*/\n\nexport function capture(regex, reducers, acc, string) {\n    const output = exec(regex, (tokens) => reduce(reducers, acc, tokens), string);\n\n    // If tokens is undefined exec has failed to apply regex to string\n    return output === undefined ?\n        // If there is a catch function, call it, otherwise error out\n        reducers.catch ?\n            reducers.catch(acc, string) :\n            error(regex, reducers, string) :\n\n        // Return the accumulator\n        output ;\n}\n\nexport default curry(capture, true);\n", "/**\nid(value)\nReturns `value`.\n**/\n\nexport default function id(value) { return value; }\n", "/**\noverload(fn, object)\n\nReturns an overloaded.\n\nTakes a `fn` that returns a string key, and an `object` of key:function\npairs. The returned function calls `fn` with all arguments to get a key,\nthen calls the function at `object[key]` with all arguments.\n\nWhere `fn` returns `undefined`, `object.default` is called if it is defined\nin `object`, otherwise `overload` throws a 'no function defined for key' error.\n\n```\nvar handleEvent = overload(get('type'), {\n    click:   (e) => {...},\n    input:   (e) => {...},\n    default: (e) => {...}\n});\n```\n*/\n\n\nexport default function overload(fn, map) {\n    return function overload() {\n        const key     = fn.apply(this, arguments);\n        const handler = (map[key] || map.default);\n\n        if (!handler) {\n            throw new Error('overload() no function defined for key \"' + key + '\"');\n        }\n\n        return handler.apply(this, arguments);\n    };\n}\n", "/**\nnoop()\nDoes nothing, returns undefined.\n**/\n\nexport default function noop() {}\n", "/**\nassign(node, properties)\n\nAssigns each property of `properties` to `node`, as a property where that\nproperty exists in `node`, otherwise as an attribute.\n\nIf `properties` has a property `'children'` it must be an array of nodes;\nthey are appended to 'node'.\n\nThe property `'html'` is aliased to `'innerHTML'`. The property `'text'`\nis aliased to `'textContent'`. The property `'tag'` is treated as an alias\nof `'tagName'` (which is ignored, as `node.tagName` is read-only). The\nproperty `'is'` is also ignored.\n*/\n\nimport curry from 'fn/curry.js';\nimport id from 'fn/id.js';\nimport noop from 'fn/noop.js';\nimport overload from 'fn/overload.js';\n\nconst assignProperty = overload(id, {\n\t// Ignore read-only properties or attributes\n\tis: noop,\n\ttag: noop,\n\n\tdata: function(name, node, object) {\n\t\t// Strip undefined\n\t\tfor (name in object) {\n\t\t\tif (object[name] === undefined) {\n\t\t\t\tdelete object[name];\n\t\t\t}\n\t\t}\n\t\t//console.log(Object.assign({}, object));\n\t\tObject.assign(node.dataset, object);\n\t},\n\n\tdataset: function(name, node, object) {\n\t\tObject.assign(node.dataset, object);\n\t},\n\n\thtml: function(name, node, content) {\n\t\tnode.innerHTML = content;\n\t},\n\n\ttext: function(name, node, content) {\n\t\tnode.textContent = content;\n\t},\n\n\tchildren: function(name, node, content) {\n\t\t// Empty the node and append children\n\t\tnode.innerHTML = '';\n\t\tnode.append.apply(node, content);\n\t},\n\n\t// SVG elements have a read-only properties, and must be set as string\n\t// attributes. Todo: explore the SVG property API to make these take\n\t// advantage of it\n\tpoints:    setAttribute,\n    cx:        setAttribute,\n    cy:        setAttribute,\n    r:         setAttribute,\n\tx:         setAttribute,\n\ty:         setAttribute,\n\tdx:        setAttribute,\n\tdy:        setAttribute,\n\ttransform: setAttribute,\n    preserveAspectRatio: setAttribute,\n    viewBox:   setAttribute,\n\n\tdefault: function(name, node, content) {\n\t\tif (name in node) {\n\t\t\tnode[name] = content;\n\t\t}\n\t\telse {\n\t\t\tnode.setAttribute(name, content);\n\t\t}\n\t}\n});\n\nfunction setAttribute(name, node, content) {\n\tnode.setAttribute(name, content);\n}\n\nexport function assign(node, attributes) {\n\tvar names = Object.keys(attributes);\n\tvar n = names.length;\n\n\twhile (n--) {\n\t\tassignProperty(names[n], node, attributes[names[n]]);\n\t}\n\n\treturn node;\n}\n\nexport default curry(assign, true);\n", "\nimport id       from 'fn/id.js';\nimport overload from 'fn/overload.js';\nimport assign   from './assign.js';\n\nconst svgNamespace = 'http://www.w3.org/2000/svg';\n\nconst template      = document.createElement('template');\nconst typeofContent = (type, content) => (content && typeof content);\n\n// Constructors\n\nfunction createContextFragment(context, html = '') {\n    const range = document.createRange();\n    range.selectNode(context);\n    return range.createContextualFragment(html);\n}\n\nconst createSVG = overload(typeofContent, {\n    string: function(tag, html) {\n        const node = document.createElementNS(svgNamespace, tag);\n        node.innerHTML = html;\n        return node;\n    },\n\n    object: function(tag, object) {\n        const node = document.createElementNS(svgNamespace, tag);\n\n        // Is it array-like?\n        if (typeof object.length === 'number') {\n            // Be careful here in case object is a live NodeList, which will\n            // mutate as you iterate over it. Applying object to .append()\n            // appears to not have this problem, and will work on arrays.\n            node.append.apply(node, object);\n        }\n        else {\n            assign(node, object);\n        }\n\n        return node;\n    },\n\n    default: (tag) => document.createElementNS(svgNamespace, tag)\n});\n\nconst createHTML = overload(typeofContent, {\n    string: function(tag, html) {\n        const node = document.createElement(tag);\n        node.innerHTML = html;\n        return node;\n    },\n\n    object: function(tag, object) {\n        const node = document.createElement(tag);\n\n        // Is it array-like?\n        if (typeof object.length === 'number') {\n            // Be careful here in case object is a live NodeList, which will\n            // mutate as you iterate over it. Applying object to .append()\n            // appears to not have this problem, and will work on arrays.\n            node.append.apply(node, object);\n        }\n        else {\n            assign(node, object);\n        }\n\n        return node;\n    },\n\n    default: (tag) => document.createElement(tag)\n});\n\n/**\ncreate(tag, content)\n\nConstructs and returns a new DOM node.\n\n- If `tag` is `\"text\"` a text node is created.\n- If `tag` is `\"fragment\"` a fragment is created.\n- If `tag` is `\"comment\"` a comment is created.\n- If `tag` is any other string the element `<tag></tag>` is created.\n\nWhere a comment or text node is created `content` must be a string, as is set as\ntextContent. For fragments and other nodes:\n\n- If `content` is a string it is set as innerHTML.\n- If `content` is array-like its items are appended to node. Note that where\n`content` is a NodeList, this removes nodes from whatever the NodeList belongs\nto.\n- If `content` is an object its properties are assigned as node properties or\nattributes.\n\n##### `create(tag, content, context)`\n\nWhere `tag` is `fragment` there is an optional third parameter `context`, which\nmust be an element. The fragment parser is run in the context of this element.\n\n```\ncreate('fragment', '<li>', create('ul'));\n```\n**/\n\nconst create = overload(id, {\n    comment: function(tag, text) {\n        return document.createComment(text || '');\n    },\n\n    fragment: overload(typeofContent, {\n        string: function(tag, html, context) {\n            if (context) {\n                return createContextFragment(context, html);\n            }\n\n            template.innerHTML = html;\n            return template.content.cloneNode(true);\n        },\n\n        object: function(tag, object, context) {\n            // If there is context, create a context-aware fragment\n            const fragment = context ?\n                createContextFragment(context) :\n                document.createDocumentFragment() ;\n\n            // Is object array-like?\n            if (typeof object.length === 'number') {\n                // Be careful here in case object is a live NodeList, which will\n                // mutate as you iterate over it. Applying object to .append()\n                // appears to not have this problem, and will work on arrays.\n                fragment.append.apply(fragment, object);\n            }\n            else {\n                assign(fragment, object);\n            }\n\n            return fragment;\n        },\n\n        default: () => document.createDocumentFragment()\n    }),\n\n    /*text: function (tag, text) {\n        return document.createTextNode(text || '');\n    },*/\n\n    circle:   createSVG,\n    ellipse:  createSVG,\n    g:        createSVG,\n    glyph:    createSVG,\n    image:    createSVG,\n    line:     createSVG,\n    rect:     createSVG,\n    use:      createSVG,\n    path:     createSVG,\n    pattern:  createSVG,\n    polygon:  createSVG,\n    polyline: createSVG,\n    svg:      createSVG,\n    tspan:    createSVG,\n    text:     createSVG,\n\n    default:  createHTML\n});\n\nexport default create;\n\n", "\n/**\ntoLoadPromise(element)\n**/\n\nconst onceEvent = { once: true };\n\nexport default function toLoadPromise(element) {\n    return new Promise((resolve, reject) => {\n        element.addEventListener('load', resolve, onceEvent);\n        element.addEventListener('error', reject, onceEvent);\n    });\n}\n", "\n/**\ntoPrefetchPromise(url)\nGenerate a promise of <link rel=\"preload\"> load state for each URL. Currently\nsupports prefetching stylesheets only. (TODO: Parse url for file extension)\n**/\n\nimport cache         from 'fn/cache.js';\nimport create        from '../create.js';\nimport toLoadPromise from './to-load-promise.js';\n\nexport default cache((url) => {\n    if (!url || url.includes('undefined')) {\n        throw new Error('ERRR?')\n    }\n    const link    = create('link', { rel: 'preload', as: 'style', href: url });\n    const promise = toLoadPromise(link);\n    document.head.append(link);\n    return promise;\n});\n", "\n\nimport create from '../create.js';\n\nconst $internals = Symbol('internals');\n\nfunction attachInternals(element) {\n    var internals;\n\n    // Use native attachInternals where it exists\n    if (element.attachInternals) {\n        internals = element.attachInternals();\n        if (internals.setFormValue) {\n            return internals;\n        }\n    }\n    else {\n        internals = {\n            shadowRoot: elem.shadowRoot\n        };\n    }\n\n    // Otherwise polyfill it with a pseudo internals object, actually a hidden\n    // input that we put inside element (but outside the shadow DOM). We may\n    // not yet put this in the DOM however â€“ it violates the spec to give a\n    // custom element children before it's contents are parsed. Instead we\n    // wait until connectCallback.\n    internals.polyfillInput = create('input', { type: 'hidden', name: elem.name });\n    elem.appendChild(internals.polyfillInput);\n\n    // Polyfill internals object setFormValue\n    internals.setFormValue = function(value) {\n        this.input.value = value;\n    };\n\n    return internals;\n}\n\nexport function createInternals(Element, element, shadow) {\n    return (element[$internals] = Element.formAssociated ?\n        attachInternals(element) :\n        { shadowRoot: shadow }\n    );\n}\n\nexport function getInternals(element) {\n    // Default to an empty object\n    return element[$internals];// || (element[$internals] = {});\n}\n", "\n/**\nelement(tag, lifecycle, properties, stylesheet, message)\n\nRegisters a custom element `tag` and returns its constructor.\n\n- `tag`: A string in the form `'custom-name'`, `'<custom-name>'`,\n`'tag is=\"custom-name\"'` or `'<tag is=\"custom-name\">'`\n- `lifecycle`: `{\n    mode:       'open' or 'closed'\n    focusable:  true or false\n    shadow:     html string or '#template-id' or fragment\n\n    // Styleheet\n    stylesheet: optional string path to stylesheet for shadow DOM\n\n    // Lifecycle handlers\n    construct:  called during element construction\n    connect:    called when element added to DOM\n    load:       called when stylesheet loaded\n    disconnect: called when element removed from DOM\n\n    // Form elements\n    enable:     called when form element enabled\n    disable:    called when form element disabled\n    reset:      called when form element reset\n    restore:    called when form element restored\n}`\n- `properties`: `{\n    name: {\n        construct: fn called before lifecycle.construct\n        attribute: fn called on `element.setAttribute('name', ...)`\n        set:       fn called on setting property 'name'\n        get:       fn called on getting property 'name'\n    }\n}`\n- `stylesheet`: url of a stylesheet to load in to the shadow DOM\n- `message`: optional debug message to logged when element is registered\n\nThe name form `'tag is=\"element-name\"'` creates customised built-in elements in\nbrowsers that support the feature. Safari does not, but support is somewhat\npolyfilled. Mileage will vary.\n\n#### Lifecycle\n\nLifecycle handlers are called with the element as `this` and with the parameters\n`shadow` and `internals`.\n\nOn initialisation the `construct` handler is called. Set up the shadow root and\ndefine event handlers here. Children and attributes must not be inspected or\nassigned at this point: doing so will throw an error when constructed via\n`document.createElement()`.\n\nFollowing that, attribute handlers in `properties` are called for attributes\ndeclared in the HTML. The HTML parser normally calls these in source order.\n\nThen the `connect` handler is called when the element is placed in the DOM, or\nif it is already in the DOM and is being upgraded.\n\nBoth `load` and `slotchange` are asynchronous. Things get a little tricky here.\nThe order of `load` callbacks and `'slotchange'` listeners cannot be guaranteed\nin Safari. When there is an empty cache `slotchange` comes first, as it always\ndoes in other browsers, otherwise `load` happens first.\n\nWhere there is a stylesheet loading, most browsers call `'slotchange'` listeners\n(asynchronously) before `load` â€“ except Safari, where if the stylesheet is\nalready cached `load` is called before `'slotchange'` listeners. (TODO: I would\nlike to guarantee `slotchange` before `load`, but it is not clear how to delay\n`load`... if there is no slotted content, `slotchange` may not be called at\nall...)\n\nFinally, `connect` and `disconnect` are called whenever the element is inserted\ninto or removed from the DOM.\n\nThe effects of the `mode` option are subtle. In 'closed' mode, the element is\nnot given a publicly accessible `shadowRoot` property, and events that traverse\nthe shadow boundary are retargeted (as they are in 'open' mode) but also have\ntheir `path` list truncated.\n\n### Properties\n\nWhere the `properties` object contains a definition for a `value` property, work\nis done to give the element form field behaviour. The constructor is assigned\nthe property `formAssociated` which signals to the browser that it constructs\nform fields. Where they are not defined in `properties` the prototype is\nassigned default handlers for the standard properties `type`, `name`, `form`,\n`labels`, `validity`, `validationMessage`, `willValidate`, `checkValidity`\nand `reportValidity`. Form behaviour is also mildly polyfilled in browsers\nwithout support by inserting a hidden input inside the element but outside the\nshadow DOM. Mileage will vary. Managing focus can be problematic without browser\nsupport.\n*/\n\nimport capture           from 'fn/capture.js';\nimport create            from './create.js';\nimport toLoadPromise     from './element/to-load-promise.js';\nimport toPrefetchPromise from './element/to-prefetch-promise.js';\nimport { createInternals, getInternals } from './element/internals.js';\n\nconst define  = Object.defineProperties;\nconst nothing = {};\n\nconst constructors = {\n    // We need list only those whose constructor names do not match their tag\n    'a':        HTMLAnchorElement,\n    'article':  HTMLElement,\n    'dl':       HTMLDListElement,\n    'p':        HTMLParagraphElement,\n    'br':       HTMLBRElement,\n    'fieldset': HTMLFieldSetElement,\n    'hr':       HTMLHRElement,\n    'img':      HTMLImageElement,\n    'li':       HTMLLIElement,\n    'ol':       HTMLOListElement,\n    'optgroup': HTMLOptGroupElement,\n    'q':        HTMLQuoteElement,\n    'section':  HTMLElement,\n    'textarea': HTMLTextAreaElement,\n    'td':       HTMLTableCellElement,\n    'th':       HTMLTableCellElement,\n    'tr':       HTMLTableRowElement,\n    'tbody':    HTMLTableSectionElement,\n    'thead':    HTMLTableSectionElement,\n    'tfoot':    HTMLTableSectionElement,\n    'ul':       HTMLUListElement\n};\n\nconst formProperties = {\n    // These properties echo those provided by native form controls.\n    // They are not strictly required, but provided for consistency.\n    //type: { value: 'text' },\n\n    name: {\n        set: function(name) { return this.setAttribute('name', name); },\n        get: function()     { return this.getAttribute('name') || ''; }\n    },\n\n    form:              { get:   function() { return getInternals(this).form; }},\n    labels:            { get:   function() { return getInternals(this).labels; }},\n    validity:          { get:   function() { return getInternals(this).validity; }},\n    validationMessage: { get:   function() { return getInternals(this).validationMessage; }},\n    willValidate:      { get:   function() { return getInternals(this).willValidate; }},\n    checkValidity:     { value: function() { return getInternals(this).checkValidity(); }},\n    reportValidity:    { value: function() { return getInternals(this).reportValidity(); }}\n};\n\nconst shadowParameterIndex = 0;\n\nlet supportsCustomisedBuiltIn = false;\n\nfunction getElementConstructor(tag) {\n        // Return a constructor from the known list of tag names â€“ not all tags\n        // have constructor names that match their tags\n    return constructors[tag]\n        // Or assemble the tag name in the form \"HTMLTagElement\" and return\n        // that property of the window object\n        || window['HTML' + tag[0].toUpperCase() + tag.slice(1) + 'Element']\n        || (() => {\n            throw new Error('Constructor not found for tag \"' + tag + '\"');\n        })();\n}\n\n// Capture name and tag from <element-name> or <tag is=\"element-name\">, syntax\n// brackets and quotes optional\nconst parseNameTag = capture(/^\\s*<?([a-z][\\w]*-[\\w-]+)>?\\s*$|^\\s*<?([a-z][\\w]*)\\s+is[=\\s]*[\"']?([a-z][\\w]*-[\\w-]+)[\"']?>?\\s*$/, {\n    1: (data, captures) => ({\n        name: captures[1]\n    }),\n\n    2: (data, captures) => ({\n        name: captures[3],\n        tag:  captures[2]\n    }),\n\n    catch: function(data, name) {\n        throw new SyntaxError('dom element() â€“ name must be of the form \\'element-name\\' or \\'tag is=\"element-name\"\\' (' + name + ')')\n    }\n}, null);\n\nfunction constructProperty(element, descriptor) {\n    if (descriptor.construct) descriptor.construct.apply(element);\n    return element;\n}\n\nfunction transferProperty(element, key) {\n    if (element.hasOwnProperty(key)) {\n        const value = element[key];\n        delete element[key];\n        element[key] = value;\n    }\n    return element;\n}\n\nfunction createShadow(elem, options, stylesheet) {\n    // Create a shadow root. Shadows may be 'open' or 'closed'. Closed shadows\n    // are not exposed via element.shadowRoot, and events propagating from\n    // inside of them report the element as target. Default to 'closed'.\n    const shadow = elem.attachShadow({\n        mode:           options.mode || 'closed',\n        delegatesFocus: options.focusable || false\n    });\n\n    if (stylesheet) {\n        const link = create('link', { rel: 'stylesheet', href: stylesheet });\n        shadow.append(link);\n    }\n\n    return shadow;\n}\n\nfunction fillShadowFromTemplate(shadow, template) {\n    // It's a string\n    if (typeof template === 'string') {\n        // It's an id of a template\n        if (template[0] === '#') {\n            shadow.appendChild(\n                document.getElementById(template.slice(1))\n                .content.clone(true)\n            );\n        }\n        // It's html\n        else {\n            shadow.innerHTML = template;\n        }\n    }\n    // It's a <template>\n    else {\n        shadow.appendChild(template.content.clone(true));\n    }\n\n    return shadow;\n}\n\nfunction hasPropertyAttribute(option) {\n    return !!option.attribute;\n}\n\nfunction hasPropertyDefinition(option) {\n    return option.set || option.get || option.hasOwnProperty('value');\n}\n\nfunction groupAttributeProperty(data, entry) {\n    if (hasPropertyAttribute(entry[1])) {\n        data.attributes[entry[0]] = entry[1].attribute;\n    }\n\n    if (hasPropertyDefinition(entry[1])) {\n        data.properties[entry[0]] = entry[1];\n    }\n\n    return data;\n}\n\nexport default function element(definition, lifecycle, api, stylesheet, log = '') {\n    const { name, tag } = parseNameTag(definition);\n\n    // Get the element constructor or the base HTMLElement constructor\n    const constructor = typeof tag === 'string' ?\n        getElementConstructor(tag) :\n        HTMLElement ;\n\n    const { attributes, properties } = api ?\n        Object.entries(api).reduce(groupAttributeProperty, {\n            attributes: {},\n            properties: {}\n        }) :\n        nothing ;\n\n    function Element() {\n        // Construct an instance from Constructor using the Element prototype\n        const element = Reflect.construct(constructor, arguments, Element);\n\n        // Make shadow if mode or template have been set\n        const shadow = lifecycle.mode || lifecycle.shadow ?\n            createShadow(element, lifecycle, stylesheet || lifecycle.stylesheet) :\n            undefined ;\n\n        // Fill shadow with template\n        if (lifecycle.shadow) {\n            fillShadowFromTemplate(shadow, lifecycle.shadow);\n        }\n\n        // Get access to the internals object. If form associated, internals is\n        // the form control API internals object. We're gonna be rude and\n        // extend it.\n        const internals = createInternals(Element, element, shadow);\n        const params = internals.params = [shadow, internals];\n\n        // Flag unconnected until first connect\n        internals.unconnected = true;\n\n        // Flag support for custom built-ins. We know this when tag exists and\n        // Element constructor is called\n        if (tag) supportsCustomisedBuiltIn = true;\n\n        if (properties) {\n            // Loop over property descriptors and call descriptor construct()\n            // function if it exists\n            Object.values(properties).reduce(constructProperty, element);\n        }\n\n        if (lifecycle.construct) lifecycle.construct.apply(element, params);\n\n        // At this point, if properties have been set before the element was\n        // upgraded they already exist on the element itself, where we have\n        // just upgraded it's protytype to define those properties. Those\n        // definitions will never be reached. Either:\n        //\n        // 1. Define properties on the instance instead of the prototype, as in\n        //    Object.defineProperties(element, properties);\n        //\n        // 2. Take a great deal of care when authoring not to set properties\n        //    before an element is upgraded. We can't impose a restriction like that.\n        //\n        // 3. Copy defined properties to their prototype handlers and delete\n        //    them on the instance.\n        //\n        // Let's go with 3. I'm not happy we have to do this, though.\n        if (properties) {\n            Object.keys(properties).reduce(transferProperty, element);\n        }\n\n        // Avoid flash of unstyled content in shadow DOMs that must load assets.\n        if (shadow) {\n            const links = shadow.querySelectorAll('link[rel=\"stylesheet\"]');\n\n            if (links.length) {\n                // Hide all content other than the default slot until stylesheets\n                // have loaded. We keep the default slot visible as that content\n                // was visible before upgrade and we do not want it to momentarily\n                // disappear.\n                const style = create('style', '*:not(:has(slot:not([name]))) { display: none !important; }');\n                shadow.append(style);\n\n                internals.stylesheetsLoadPromise = Promise\n                .all(Array.from(links, toLoadPromise))\n                .finally(() => style.remove());\n            }\n        }\n\n        return element;\n    }\n\n    // Prefetch stylesheet\n    if (stylesheet) {\n        toPrefetchPromise(stylesheet);\n        log = window.DEBUG ?\n            log + ' â€“ stylesheet ' + stylesheet :\n            log ;\n    }\n\n    // Properties\n\n    // Must be defined before attributeChangedCallback, but I cannot figure out\n    // why. Where one of the properties is `value`, the element is set up as a\n    // form element.\n    Element.prototype = Object.create(constructor.prototype, properties) ;\n\n    if (properties && properties.value) {\n        // Flag the Element class as formAssociated\n        Element.formAssociated = true;\n\n        // Define standard form properties\n        define(Element.prototype, formProperties);\n\n        if (lifecycle.enable || lifecycle.disable) {\n            Element.prototype.formDisabledCallback = function(disabled) {\n                const internals = getInternals(this);\n                return disabled ?\n                    lifecycle.disable && lifecycle.disable.apply(this, internals.params) :\n                    lifecycle.enable && lifecycle.enable.apply(this, internals.params) ;\n            };\n        }\n\n        if (lifecycle.reset) {\n            Element.prototype.formResetCallback = function() {\n                const internals = getInternals(this);\n                return lifecycle.reset.apply(this, internals.params);\n            };\n        }\n\n        if (lifecycle.restore) {\n            Element.prototype.formStateRestoreCallback = function() {\n                const internals = getInternals(this);\n                const params    = internals.params;\n                return lifecycle.restore.apply(this, internals.params);\n            };\n        }\n    }\n\n\n    // Attributes\n\n    if (attributes) {\n        Element.observedAttributes = Object.keys(attributes);\n        Element.prototype.attributeChangedCallback = function(name, old, value) {\n            return attributes[name].call(this, value) ;\n        };\n    }\n\n\n    // Lifecycle\n\n    Element.prototype.connectedCallback = function() {\n        const internals = getInternals(this);\n\n        // If we have simulated form internals (for Safari), append the hidden\n        // input now\n        if (internals.polyfillInput) {\n            elem.appendChild(internals.polyfillInput);\n        }\n\n        // If this is the first connect and there is a lifecycle.load fn,\n        // unconnected is true\n        if (internals.unconnected) {\n            if (lifecycle.load && internals.stylesheetsLoadPromise) {\n                internals.stylesheetsLoadPromise.then(() =>\n                    lifecycle.load.apply(this, internals.params)\n                );\n            }\n            else if (lifecycle.load) {\n                // Guarantee that lifecycle load is called asynchronously in\n                // cases where there is nothing to load\n                Promise.resolve().then(() =>\n                    lifecycle.load.apply(this, internals.params)\n                );\n            }\n\n            delete internals.unconnected;\n        }\n\n        lifecycle.connect && lifecycle.connect.apply(this, internals.params);\n    }\n\n    if (lifecycle.disconnect) {\n        Element.prototype.disconnectedCallback = function() {\n            const internals = getInternals(this);\n            return lifecycle.disconnect.apply(this, internals.params);\n        };\n    }\n\n    // Log registration to console\n    window.console &&\n    window.console.log('%c<' + (tag ? tag + ' is=' + name + '' : name) + '>%c ' + log, 'color:#3a8ab0;font-weight:600;', 'color:#888888;font-weight:400;');\n\n    // Define the element\n    window.customElements.define(name, Element, tag && { extends: tag });\n\n    // Safari partial polyfill.\n    // Where tag is supplied, element should have been registered as a customised\n    // built-in and the constructor would have run if any were in the DOM already.\n    // However, Safari does not support customised built-ins. Here we attempt to\n    // go some way towards filling in support by searching for elements and\n    // assigning their intended APIs to them.\n    if (tag && !supportsCustomisedBuiltIn) {\n        if (window.DEBUG) {\n            console.warn('Browser does not support customised built-in elements, polyfilling <' + tag + ' is=\"' + name + '\">');\n        }\n\n        document.querySelectorAll('[is=\"' + name + '\"]').forEach((element) => {\n            // Define properties on element\n            if (properties) {\n                define(element, properties);\n            }\n\n            // Construct an instance from Constructor using the Element prototype\n            const shadow = lifecycle.mode || lifecycle.shadow ?\n                createShadow(element, lifecycle, stylesheet || lifecycle.stylesheet) :\n                undefined ;\n\n            // Get access to the internals object\n            const internals = createInternals(Element, element, shadow);\n\n            // Run constructor\n            lifecycle.construct && lifecycle.construct.call(element, shadow, internals);\n\n            // Detect and run attributes\n            let name;\n            for (name in attributes) {\n                // elements.attributes is sometimes undefined... why?\n                const attribute = element.attributes[name];\n                if (attribute) {\n                    attributes[name].call(element, attribute.value);\n                }\n            }\n\n            // Run connected callback\n            lifecycle.connect && lifecycle.connect.call(element, shadow, internals);\n        });\n    }\n\n    return Element;\n}\n\nexport { getInternals };\n", "\n/**\nequals(a, b)\nCompares `a` and `b` for deep equality and returns `true` where they are equal,\notherwise false.\n**/\n\nimport curry from './curry.js';\n\nexport function equals(a, b) {\n    // Fast out if references are for the same object\n    if (a === b) { return true; }\n\n    // If either of the values is null, or not an object, we already know\n    // they're not equal so get out of here\n    if (a === null ||\n        b === null ||\n        typeof a !== 'object' ||\n        typeof b !== 'object') {\n        return false;\n    }\n\n    // Compare their enumerable keys\n    const akeys = Object.keys(a);\n    const bkeys = Object.keys(b);\n\n    let n = akeys.length;\n    while (n--) {\n        // Has the property been set to undefined on a?\n        if (a[akeys[n]] === undefined) {\n            // We don't want to test if it is an own property of b, as\n            // undefined represents an absence of value\n            if (b[akeys[n]] !== undefined) {\n                return false;\n            }\n        }\n        else {\n            // console.log(equals(a[akeys[n]], b[akeys[n]]), akeys[n], a[akeys[n]], b[akeys[n]]);\n            if (!b.hasOwnProperty(akeys[n]) || !equals(a[akeys[n]], b[akeys[n]])) {\n                return false;\n            }\n        }\n\n        const i = bkeys.indexOf(akeys[n]);\n        if (i > -1) {\n            bkeys.splice(i, 1);\n        }\n    }\n\n    n = bkeys.length;\n    while (n--) {\n        // Has the property been set to undefined on b?\n        if (b[bkeys[n]] === undefined) {\n            if (a[bkeys[n]] !== undefined) {\n                return false;\n            }\n        }\n        else {\n            // We already know a does not have own property bkeys[n], because\n            // we have already been through all the enumerable properties\n            return false;\n        }\n    }\n\n    return true;\n}\n\nexport default curry(equals, true);\n", "\n/**\nget(name, object)\nGet property `name` of `object`.\n*/\n\nimport curry from './curry.js';\n\nexport function get(key, object) {\n    // Todo? Support WeakMaps and Maps and other map-like objects with a\n    // get method - but not by detecting the get method\n    return object[key];\n}\n\nexport default curry(get, true);\n", "/**\narg(n)\n\nReturns a function that returns `argument[n]`.\n\n```js\n```\n**/\n\nexport default function arg(n) {\n    return function arg() {\n        return arguments[n];\n    };\n}\n", "/**\nself()\nReturns `this`.\n*/\n\nexport default function self() { return this; }\n", "\n/**\nnothing\nA frozen array-like and stream-like object that contains no value.\n**/\n\nimport arg  from './arg.js';\nimport id   from './id.js';\nimport noop from './noop.js';\nimport self from './self.js';\n\nconst create = Object.create;\nconst freeze = Object.freeze;\n\nexport default freeze(create(create(Object.prototype, {\n    // Array methods\n    at:        { value: noop },\n    shift:     { value: noop },\n    push:      { value: noop },\n    forEach:   { value: noop },\n    join:      { value: function() { return ''; } },\n    every:     { value: function() { return true; } },\n    filter:    { value: self },\n    find:      { value: noop },\n    findIndex: { value: function() { return -1; } },\n    flat:      { value: self },\n    flatMap:   { value: self },\n    includes:  { value: function() { return false; } },\n    indexOf:   { value: function() { return -1; } },\n    map:       { value: self },\n    reduce:    { value: arg(1) },\n    sort:      { value: self },\n\n   // Stream methods\n    each:      { value: self },\n    pipe:      { value: id },\n    start:     { value: self },\n    stop:      { value: self },\n    done:      { value: self },\n\n    // Primitive coercion\n    valueOf:   { value: function() { return null; } }\n}), {\n    length: { value: 0 }\n}));\n", "\nconst DEBUG  = false;//window.DEBUG && window.DEBUG.signal !== false;\nconst assign = Object.assign;\n\nlet evaluatingSignal;\nlet id = 0;\n\nfunction setDependency(signal, dependent) {\n    // Set signal as an input of dependent\n    let n = 0;\n    while (dependent[--n]) if (dependent[n] === signal) break;\n    dependent[n] = signal;\n\n    // Set dependent as an output of signal\n    n = -1;\n    while (signal[++n]) if (signal[n] === dependent) break;\n    signal[n] = dependent;\n\n    if (DEBUG) console.log(\n        '%cSignal%c connect%c ' + signal.constructor.name + '#' + signal.id + ' - ' + dependent.constructor.name + '#' + dependent.id,\n        'color: #718893; font-weight: 300;',\n        'color: #3896BF; font-weight: 300;',\n        'color: #718893; font-weight: 300;'\n    );\n}\n\nfunction invalidateDependents(signal) {\n    if (DEBUG) {\n        console.log(\n            '%cSignal%c invalidate%c ' + signal.constructor.name + '#' + signal.id + (signal.name ? ' \"' + signal.name + '\"' : ''),\n            'color: #718893; font-weight: 300;',\n            'color: #3896BF; font-weight: 300;',\n            'color: #718893; font-weight: 300;'\n        );\n    }\n\n    let n = -1;\n    let dependent;\n    while (dependent = signal[++n]) {\n        signal[n] = undefined;\n        dependent.invalidate(signal);\n    }\n}\n\nexport function hasInput(signal, input) {\n    // Check if input exists in the -ve indexes\n    let n = 0;\n    while (signal[--n]) if (signal[n] === input) return true;\n    return false;\n}\n\n\n/**\nSignal\n\nA signal is an object that represents a value that may change. A signal has\nessentially one property, `.value`. A state signal can have its `.value`\nwritten, a compute signal's `.value` may only be read.\n\nThe `Signal` constructor is not called directly, but calling `Signal.of(value)`\ncreates a state signal, and `Signal.from(fn)` creates a compute signal.\n**/\n\nexport default class Signal {\n    /**\n    Signal.isSignal(object)\n\n    Returns `true` where `object` is an instance of `Signal`.\n\n    This guarantees that `object` has a gettable `value` property. This is not\n    true of an ObserveSignal, which is not really a signal at all â€“ it cannot\n    have dependencies â€“ but is only evaluated as one when invalidated.\n    **/\n\n    static isSignal(object) {\n        return object instanceof Signal;\n    }\n\n    /**\n    Signal.of()\n    Signal.of(value)\n\n    Creates a state signal that has essentially one property, `.value`.\n    When `.value` is set the signal becomes invalid, stale, out of date,\n    irrelevant, historic, old, and any signals that depend on it are invalidated.\n    **/\n\n    static of(value) {\n        return new ValueSignal(value);\n    }\n\n    /**\n    Signal.from(fn)\n    Signal.from(promise)\n    Signal.from(stream)\n\n    Creates a compute signal from a function, where `fn` computes a value by\n    reading other signals' values. This signal is then invalidated when any of\n    the read signals are invalidated.\n\n    Creates a state signal from a promise or stream that invalidates\n    dependencies as the promise or streams' values resolve.\n    **/\n\n    static from(fn, context) {\n        // Promise\n        if (fn.then) {\n            const signal = Signal.of();\n            fn.then((value) => signal.value = value);\n            return signal;\n        }\n\n        // Pipeable\n        if (fn.pipe) {\n            const signal = Signal.of();\n            fn.pipe({ push: (value) => signal.value = value });\n            return signal;\n        }\n\n        // Function\n        return new ComputeSignal(fn, context);\n    }\n\n    static fromProperty(name, object) {\n        // Function\n        return new PropertySignal(name, object);\n    }\n\n    /**\n    Signal.observe(signal, fn, initial)\n\n    Returns an observer that calls `fn` with `signal.value` whenever the signal\n    is invalidated. If `signal` does not have an initial value equal to `initial`\n    `fn` is also called immediately.\n    **/\n\n    static observe(signal, fn, initial) {\n        // Add to signals called on invalidation\n        return new ObserveSignal(signal, fn, initial);\n    }\n\n    /**\n    Signal.evaluate(signal, fn[, context])\n\n    A function for building objects that behave as compute signals.\n\n    Evaluates `object` as a signal by applying it to `fn` and returning the\n    result. Signals read during `fn()` have `object` registered as a dependent,\n    so `object.invalidate()` is called when any of those signals are invalidated.\n    It's the same function as that used internally to evaluate signals.\n\n    Typically `object.invalidate()` would cue a `Signal.evaluate(object, fn)` at\n    some point in the future. (It is not great to `Signal.evaluate(object, fn)`\n    synchronously inside `.invalidate()`, although this should only lead to\n    wasted invalidations, not bad results. Errm, in most cases, at least.)\n    **/\n\n    static evaluate(signal, fn, context = signal) {\n        // Make signal the evaluating signal for the duration of this\n        // synchronous evaluation of fn()\n        const previous = evaluatingSignal;\n        evaluatingSignal = signal;\n\n        if (DEBUG) console.group(\n            '%cSignal%c evaluate%c ' + evaluatingSignal.constructor.name + '#' + evaluatingSignal.id + (evaluatingSignal.name ? ' \"' + evaluatingSignal.name + '\"' : ''),\n            'color: #718893; font-weight: 300;',\n            'color: #3896BF; font-weight: 300;',\n            'color: #718893; font-weight: 300;'\n        );\n\n        const value = fn.apply(context);\n\n        if (window.DEBUG && window.DEBUG.signal !== false) console.groupEnd();\n\n        evaluatingSignal = previous;\n        return value;\n    }\n\n    /*\n    Signal.evaluating\n    The signal that is currently being evaluated, or undefined. This is exposed\n    so that Data() can make a better call about when to create signals (if there\n    is no evaluating signal, it needn't make a signal when a property is\n    accessed). Deliberately undocumented.\n    */\n\n    static get evaluating() {\n        return evaluatingSignal;\n    }\n\n    constructor(name) {\n        if (name) this.name = name;\n\n        if (DEBUG) {\n            this.id   = ++id;\n            console.log(\n                '%cSignal%c create%c ' + this.constructor.name + '#' + this.id + (this.name ? ' \"' + this.name + '\"' : ''),\n                'color: #718893; font-weight: 300;',\n                'color: #3896BF; font-weight: 300;',\n                'color: #718893; font-weight: 300;'\n            );\n        }\n    }\n\n    /**\n    .valueOf()\n\n    Enables direct use in some expressions like addition or string concatenation.\n    This may prove to be less useful than we think. For one thing, logging a\n    signal object now evaluates it, affecting the outcome.\n    **/\n\n    valueOf() {\n        return this.value;\n    }\n\n    /*\n    .toString()\n    .toJSON()\n\n    Treat `.value` as the value to output?\n    */\n\n    toString() {\n        return this.value + '' ;\n    }\n\n    toJSON() {\n        return this.value;\n    }\n}\n\n\n/*\nValueSignal(value)\n*/\n\nclass ValueSignal extends Signal {\n    #value;\n\n    constructor(value) {\n        super();\n        this.#value = value;\n    }\n\n    /**\n    .value\n\n    Getting `.value` gets value from the cache.\n\n    Setting `.value`, assuming the newly set value differs from the previous\n    value, updates the cache and invalidates dependent signals.\n    **/\n\n    get value() {\n        // If there is a signal currently evaluating then it becomes a\n        // dependency of this signal, irrespective of state of #value\n        if (evaluatingSignal) setDependency(this, evaluatingSignal);\n        return this.#value;\n    }\n\n    set value(value) {\n        // Don't update for no change in value\n        if(this.#value === value) return;\n\n        // Set cached value\n        this.#value = value;\n\n        // Invalidate dependents. If a dependent updates synchronously here\n        // we may be in trouble but #valid is true and #value is set so\n        // that's ok I think?\n        invalidateDependents(this);\n    }\n}\n\n\n/*\nComputeSignal(value)\n*/\n\nclass ComputeSignal extends Signal {\n    // Privates\n    #fn;\n    #context;\n    #valid;\n    #value;\n\n    constructor(fn, context) {\n        super();\n        this.#fn      = fn;\n        this.#context = context;\n    }\n\n    /**\n    .value\n    Getting `.value` gets a cached value or, if the signal is invalid,\n    evaluates (and caches) value from `fn()`. During evaluation this signal is\n    registered as dependent on other signals whose value is got.\n    **/\n\n    get value() {\n        // If there is a signal currently evaluating then it becomes a\n        // dependency of this signal, irrespective of state of #value\n        if (evaluatingSignal) setDependency(this, evaluatingSignal);\n        if (this.#valid) return this.#value;\n        this.#value = Signal.evaluate(this, this.#fn, this.#context);\n        this.#valid = true;\n        return this.#value;\n    }\n\n    /*\n    .invalidate(signal)\n    Invalidates this signal and calls `.invalidate(this)` on all dependent\n    signals. The `signal` parameter is the signal causing the invalidation; it\n    may be `undefined`: where it exists it is verified as a current input of\n    this before this is invalidated.\n    */\n\n    invalidate(signal) {\n        if (!this.#valid) return;\n\n        // Verify that signal has the right to invalidate this to protect us\n        // against the case where a dependent is left on another signal due to\n        // an old evaluation\n        if (signal && !hasInput(this, signal)) return;\n\n        this.#valid = false;\n\n        // Clear inputs\n        let n = 0;\n        while (this[--n]) this[n] = undefined;\n\n        // Invalidate dependents. If a dependent updates synchronously here\n        // we may be in trouble, as it would evaluate and cache this signal\n        // and overwrite dependents before we have finished invalidating\n        // this set of dependents.\n        invalidateDependents(this);\n    }\n}\n\n\n/*\nPropertySignal(value)\n*/\n\nclass PropertySignal extends Signal {\n    // Privates\n    #valid;\n    #value;\n\n    constructor(name, object) {\n        super(name);\n        this.object = object;\n    }\n\n    evaluate() {\n        return this.object[this.name];\n    }\n\n    /**\n    .value\n    Getting `.value` gets a cached value or, if the signal is invalid,\n    evaluates (and caches) value from `fn()`. During evaluation this signal is\n    registered as dependent on other signals whose value is got.\n    **/\n\n    get value() {\n        // If there is a signal currently evaluating then it becomes a\n        // dependency of this signal, irrespective of state of #value\n        if (evaluatingSignal) setDependency(this, evaluatingSignal);\n        if (this.#valid) return this.#value;\n        this.#value = Signal.evaluate(this, this.evaluate, this);\n        this.#valid = true;\n        return this.#value;\n    }\n\n    set value(value) {\n        // Don't update for no change in value.\n        if(this.#value === value) return;\n\n        const { object, name } = this;\n\n        // Set value on object and update value from object in case target is\n        // doing something funky with property descriptors that return a\n        // different value from the value set.\n        object[name] = value;\n        value = object[name];\n\n        // Don't invalidate for no change in value.\n        if(this.#value === value) return;\n\n        // Set cache by reading value back off the object in case object is\n        // doing something funky with property descriptors that return a\n        // different value from the value that was set. Rare, but it can happen.\n        this.#value = value;\n\n        // Invalidate dependents. If a dependent updates synchronously here\n        // we may be in trouble but #valid is true and #value is set so\n        // that's ok I think?\n        invalidateDependents(this);\n    }\n\n    /*\n    .invalidate(signal)\n    Invalidates this signal and calls `.invalidate(this)` on all dependent\n    signals. The `signal` parameter is the signal causing the invalidation; it\n    may be `undefined`: where it exists it is verified as a current input of\n    this before this is invalidated.\n    */\n\n    invalidate(signal) {\n        if (!this.#valid) return;\n\n        // Verify that signal has the right to invalidate this to protect us\n        // against the case where a dependent is left on another signal due to\n        // an old evaluation\n        if (signal && !hasInput(this, signal)) return;\n\n        this.#valid = false;\n\n        // Clear inputs\n        let n = 0;\n        while (this[--n]) this[n] = undefined;\n\n        // Invalidate dependents. If a dependent updates synchronously here\n        // we may be in trouble, as it would evaluate and cache this signal\n        // and overwrite dependents before we have finished invalidating\n        // this set of dependents.\n        invalidateDependents(this);\n    }\n}\n\n\n\n\n\n\n\n\n\n/*\nObserveSignal(fn)\nTEMP: are we sure we are keeping this? Used by Data.observe() and <lieral-html>.\n*/\n\nconst promise = Promise.resolve();\n\nexport class ObserveSignal {\n    #signal;\n    #fn;\n\n    constructor(signal, fn, initial) {\n        this.#signal = signal;\n        this.#fn     = fn;\n\n        // Set up dependency graph, return value\n        const value = Signal.evaluate(this, this.#evaluate);\n\n        // Run the observer if value is not initial\n        if (signal.value !== initial) this.#fn(value);\n    }\n\n    #evaluate() {\n        return this.#signal.value;\n    }\n\n    invalidate(signal) {\n        if (this.status === 'done') return;\n\n        // Verify that signal has the right to invalidate this\n        if (signal && !hasInput(this, signal)) return;\n\n        // Clear inputs\n        let n = 0;\n        while (this[--n]) this[n] = undefined;\n\n        // Evaluate and send value to consumer on next tick\n        promise.then(() => this.#fn(Signal.evaluate(this, this.#evaluate)));\n    }\n\n    stop() {\n        // Check and set status\n        if (this.status === 'done') {\n            if (window.DEBUG) {\n                console.log(this);\n                throw new Error('Stream: cannot stop() stream that is done');\n            }\n\n            return this;\n        }\n\n        this.status = 'done';\n        return this;\n    }\n}\n", "\nimport Signal from './signal.js';\n\nconst assign       = Object.assign;\nconst define       = Object.defineProperties;\nconst isExtensible = Object.isExtensible;\nconst O            = Object.prototype;\nconst $trap        = Symbol('data');\nconst properties   = { [$trap]: {} };\n\n\nfunction isMuteable(object) {\n    // Many built-in objects and DOM objects bork when calling their\n    // methods via a proxy. They should be considered not observable.\n    // I wish there were a way of whitelisting rather than\n    // blacklisting, but it would seem not.\n\n    return object\n        // Reject primitives and other frozen objects\n        // This is really slow...\n        //&& !isFrozen(object)\n        // I haven't compared this, but it's necessary for audio nodes\n        // at least, but then only because we're extending with symbols...\n        // hmmm, that may need to change...\n        && isExtensible(object)\n        // This is less safe but faster.\n        //&& (typeof object === 'object' || typeof object === 'function')\n\n        // Reject DOM nodes\n        && !Node.prototype.isPrototypeOf(object)\n        // Reject WebAudio context\n        && (window.BaseAudioContext === undefined || !BaseAudioContext.prototype.isPrototypeOf(object))\n        // Reject date, their methods don't enjoy being proxied\n        && !(object instanceof Date)\n        // Reject regex\n        && !(object instanceof RegExp)\n        // Reject maps\n        && !(object instanceof Map)\n        && !(object instanceof WeakMap)\n        // Reject sets\n        && !(object instanceof Set)\n        && !(window.WeakSet && object instanceof WeakSet)\n        // Reject TypedArrays and DataViews\n        && !ArrayBuffer.isView(object) ;\n}\n\nfunction getSignal(signals, name, object) {\n    return signals[name] || (signals[name] = Signal.fromProperty(name, object));\n}\n\nfunction isMutableProperty(object, name) {\n    // If there's a descriptor return its mutability\n    const descriptor = Object.getOwnPropertyDescriptor(object, name);\n    if (descriptor) return descriptor.writable || !!descriptor.set ;\n\n    // If there's a prototype look for property on it\n    const prototype = Object.getPrototypeOf(object);\n    if (prototype) return isMutableProperty(prototype, name);\n\n    // If there is no prototypes property must be unset\n    return true;\n}\n\nfunction getValue(signals, name, object) {\n    // If there is an evaluating signal and the property is mutable\n    return (Signal.evaluating && isMutableProperty(object, name)) ?\n        // ...read value from the signal graph\n        getSignal(signals, name, object).value :\n        // ...otherwise there is no need to register the get\n        object[name] ;\n}\n\nfunction getTrap(object) {\n    return Data(object) && object[$trap];\n}\n\n\n/*\nDataTrap(object)\n*/\n\nfunction DataTrap(object) {\n    this.signals = {};\n    this.object  = object;\n    this.data    = new Proxy(object, this);\n\n    // Define trap as object[$trap]\n    properties[$trap].value = this;\n    define(object, properties);\n}\n\nassign(DataTrap.prototype, {\n    get: function get(object, name, proxy) {\n        // Don't observe changes to symbol properties or the constructor, and\n        // don't allow Safari to log __proto__ as a Proxy. That's dangerous! It\n        // pollutes Object.prototype with [$trap], which breaks everything.\n        if (typeof name === 'symbol' || name === 'constructor' || name === '__proto__') {\n            return object[name];\n        }\n\n        const value = getValue(this.signals, name, object);\n        //console.log(value, !!Signal.evaluating, isMutableProperty(object, name));\n\n        // We are not interested in getting proxies of stuff in the prototype\n        // chain so stick to hasOwnProperty. TODO: ARE WE REALLY NOT, THO? What about\n        // values returned by getters? Eh?\n        /*if (!O.hasOwnProperty.call(object, name)) {\n            return value;\n        }*/\n\n        // Return observer\n        return Data(value) || value ;\n    },\n\n    set: function set(object, name, value, proxy) {\n        if (typeof name === 'symbol' || name === '__proto__') {\n            object[name] = value;\n            return true;\n        }\n\n        // To support arrays keep a note of pre-change length\n        const length = object.length;\n\n        // Set unproxied value on signal or directly on object\n        if (this.signals[name]) {\n            // Make sure we are setting an unproxied value.\n            this.signals[name].value = Data.objectOf(value);\n        }\n        else {\n            object[name] = Data.objectOf(value);\n        }\n\n        // Check if length has changed and update its signal if it has\n        if (name !== 'length' && object.length !== length && this.signals.length) {\n            this.signals.length.value = object.length;\n        }\n\n        // Return true to indicate success to Proxy\n        return true;\n    },\n\n    deleteProperty: function(object, name) {\n        delete object[name];\n\n        if (typeof name !== 'symbol' && name !== '__proto__' && this.signals[name]) {\n            this.signals[name].value = object[name];\n        }\n\n        // Indicate success to the Proxy\n        return true;\n    }\n});\n\n\n/*\nData(object, force)\nForces creation of an observer even where Data would normally consider\nthe object 'immutable'. Data considers DOM nodes immutable, for example, but\nnot because they are really immutable, more in order to prevent you calling node\nmethods on a node's observer proxy, which is a source of hard-to-trace errors.\nPass in `force` as `true` if you know what you are doing.\n*/\n\nexport default function Data(object, force) {\n    return !object ? undefined :\n        object[$trap] ? object[$trap].data :\n        (force || isMuteable(object)) ? (new DataTrap(object)).data :\n        undefined ;\n}\n\n/**\nData.of(object)\n\nReturns the data proxy of `object`. The data proxy is a wrapper that observes\nmutations made to `object`. There is only ever one data proxy of `object`, and\ncalls to `Data.of(object)` always return that data proxy.\n\n_Getting_ a property of a data proxy while evaluating a signal registers the\nsignal as dependent on the property. _Setting_ a property of a data proxy\nnotifies dependent signals.\n\nGetting a property of a data proxy returns a data proxy of that property\nof `object`. In this way access chains like `data.property.value` are also\nobserved.\n\nNot all objects may be proxied. Frozen objects, unextensible objects, and\nvarious others like Sets, Maps and DOM and WebAudio nodes are deemed\nimmutable or otherwise unobservable. They return `undefined`.\n**/\n\nData.of = (object) => Data(object);\n\n/**\nData.objectOf(data)\n\nReturns the un-proxied `object` wrapped by `Data.of(object)`, or, if `data` is\nalready just an object, `data`. Getting and setting properties of `object` has\nno effect on the data proxy.\n**/\n\nData.objectOf = function(object) {\n    return object && object[$trap] ?\n        object[$trap].object :\n        object ;\n};\n\n/**\nData.observe(data)\n\nReturns the un-proxied `object` wrapped by a `Data.of(object)` proxy, or,\nif `data` is already just an object, `data`.\n**/\n\nData.observe = function(name, object, fn, initial) {\n    const trap = Data(object) && object[$trap];\n    if (!trap) return;\n\n    const signal = getSignal(trap.signals, name, trap.object);\n    return Signal.observe(signal, fn, initial);\n};\n\n/*\nData.signal(path, data)\n*/\n\nData.signal = function(name, object) {\n    const trap = Data.of(object) && object[$trap];\n    return trap ?\n        getSignal(trap.signals, name, trap.object) :\n        nothing ;\n};\n", "\n/**\nisIterable(value)\n**/\n\nexport default function isIterable(object) {\n    return object && object[Symbol.iterator];\n}\n", "/**\ntoType(object)\nReturns `typeof object`.\n*/\n\nexport default (object) => typeof object;\n", "\nimport isIterable from '../is-iterable.js';\nimport nothing    from '../nothing.js';\nimport noop       from '../noop.js';\nimport overload   from '../overload.js';\nimport toType     from '../to-type.js';\n\nconst assign     = Object.assign;\nconst create     = Object.create;\n//const $input     = Symbol('input');\nconst $listeners = Symbol('done');\n\nconst call = overload(toType, {\n    function: (fn) => fn(),\n    object:   (object) => object.stop()\n});\n\n/**\npipe(stream)\nConnect stream to output. Sets up `stream[0]` and `output[-1]` (if output is\n`.stop()`able).\n**/\n\nexport function pipe(stream, output) {\n    // For internal objects `output[-1] === stream` already, but for other\n    // streams it doesn't have a reference to input, so it doesn't participate\n    // in the flow of .stop() unless we give it one. Let's use existence of\n    // .stop() to determine need for output[-1], to avoid us setting\n    // array[-1], for example, in case the consumer is an array.\n    if (output.stop) output[-1] = stream;\n\n    // Add to outputs\n    return stream[0] = output;\n}\n\n\n/*\nunpipe(streams, output)\nInternal, part of the stop cycle. Disconnects output from stream.\n*/\n\nexport function unpipe(stream, output) {\n    let n = -1;\n    let o;\n\n    // Find stream[n] that matches `output`\n    while (stream[++n] && stream[n] !== output);\n\n    if (window.DEBUG && !stream[n]) {\n        throw new Error('Stream: Cannot unpipe(), `output`, not an output of `stream`');\n    }\n\n    // Stop responding to stop() and start() on output\n    output[-1] = undefined;\n\n    // Decrement output n of higher number outputs\n    while (stream[n++]) {\n        stream[n - 1] = stream[n];\n    }\n\n    return output;\n}\n\n\n/**\nstop()\nStops a stream and all downstream streams. This calls the `done` listeners.\n**/\n\nexport function stop(stream) {\n    // Check and set status\n    if (stream.status === 'done') {\n        if (window.DEBUG) {\n            console.log(stream);\n            throw new Error('Stream: cannot stop() stream that is done');\n        }\n        return stream;\n    }\n\n    stream.status = 'done';\n\n    // If stream has not yet been piped, we don't call done() functions\n    // for streams that have not been consumed. The problem with\n    // stream[0] on its own is that it's `false` for an Each stream\n    // or other consumer. The way to identify a consumer is that it\n    // does not have a .pipe().\n    if (stream.pipe && !stream[0]) { return stream; }\n\n    // Call done functions and listeners\n    const listeners = stream[$listeners];\n    stream[$listeners] = undefined;\n\n    if (listeners) {\n        listeners.forEach(call);\n    }\n\n    // Unpiping output 0 decrements other outputs, so this loops through\n    // all outputs, in case it's a broadcast stream. Check it is stoppable,\n    // avoid trying to stop arrays\n    while (stream[0]) {\n        if (Array.isArray(stream[0])) {\n            unpipe(stream, stream[0]);\n        }\n        else {\n            stop(unpipe(stream, stream[0]));\n        }\n    }\n\n    return stream;\n}\n\n\n/**\nStream(pipeable)\nA `pipeable` is an object with `.pipe()` and `.stop()` methods, and optionally\n`.start()`.\n**/\n\n/**\nStream(fn)\nPassing a function to `Stream()` creates a readable stream. The function `fn`\nis called when a consumer is first attached to the stream. It is passed two\narguments, `push()`, used to write to the stream, and `stop()`, used to stop\nthe stream.\n**/\n\nconst readable = {\n    pipe: function(output) {\n        // Connect stream to output\n        pipe(this, output);\n\n        // Call fn(push, stop)\n        this.fn(\n            (value) => Stream.prototype.push.call(this, value),\n            () => this.stop()\n        );\n\n        // Return output stream\n        return output;\n    },\n\n    push: null,\n\n    stop: function() {\n        return this.status === 'done' ?\n            this :\n            stop(this) ;\n    }\n};\n\nexport default function Stream(pipeable) {\n    const type = typeof pipeable;\n\n    if (type === 'object') {\n        // Set pipeable as input\n        this[-1] = pipeable;\n    }\n    else if (type === 'function') {\n        // Store function\n        this.fn = pipeable;\n        // Configure stream as a readonly stream\n        assign(this, readable);\n    }\n    else if (window.DEBUG) {\n        throw new Error('new Stream() may be called with a pipeable object or a function');\n    }\n}\n\nassign(Stream.prototype, {\n    /**\n    .push(value)\n    Pushes `value` into the stream. If the stream has not been started or is\n    already stopped this will cause an error.\n    **/\n    push: function(value) {\n        // Do we need the guard??\n        return this[0] && this[0].push(value);\n    },\n\n    /**\n    .each(fn)\n    Consume the stream, calling `fn(value)` for each value in it.\n    Returns the stream.\n    **/\n    each: function(fn) {\n        return this.pipe(new Each(this, fn));\n    },\n\n    /**\n    .pipe(stream)\n    Starts a stream and pushes its values into `stream`. Returns `stream`.\n    **/\n    pipe: function(output) {\n        if (window.DEBUG && this[0]) {\n            throw new Error('Stream: cannot .pipe() a unicast stream more than once');\n        }\n\n        if (window.DEBUG && !output.push) {\n            throw new Error('Stream: attempt to .pipe() to non-pushable object');\n        }\n\n        // Connect this to output (sets this[0] and output[-1])\n        pipe(this, output);\n\n        // Tell input to .pipe(), so pipe goes back up the chain\n        this[-1].pipe(this);\n        return output;\n    },\n\n    /**\n    .broadcast(options)\n    Returns a broadcast stream. Methods called on this stream each create new\n    child streams. The first time a consumer is attached to one of these streams\n    the broadcast stream is piped, and the last consumer to be stopped stops the\n    broadcast stream.\n\n    A broadcast stream may have memory, where newly created consumers\n    immediately receive the latest value of the broadcaster when attached\n    (assuming that value is not `undefined`):\n\n    ```js\n    const broadcaster = stream.broadcast({ memory: true });\n    ```\n    **/\n    broadcast: function(options) {\n        return new Broadcast(this, options);\n    },\n\n    /**\n    .filter(fn)\n    Filters out values where `fn(value)` is falsy.\n    **/\n    /*\n    .filter(stream)\n    Filters out values where the latest value of `stream` is falsy.\n    */\n    filter: function(fn) {\n        /*return typeof fn === 'function' ?\n            new Filter(this, fn) :\n            new StreamFilter(this, fn) ;*/\n        return new Filter(this, fn);\n    },\n\n    /**\n    .flatMap(fn)\n    **/\n    flatMap: function(fn) {\n        return new FlatMap(this, fn);\n    },\n\n    /**\n    .map(fn)\n    Maps each value in the stream to `fn(value)`. Resulting values that are not\n    `undefined` are pushed downstream.\n    **/\n    map: function(fn) {\n        //return pipe(this, new Map(this, fn));\n        //return this.pipe(new Map(this, fn));\n        return new Map(this, fn);\n    },\n\n    /**\n    .reduce(fn, initial)\n    Consume the stream, calling `fn(accumulator, value)` for each value in it.\n    Returns the accumulator.\n    **/\n    reduce: function(fn, accumulator) {\n        return this.pipe(new Reduce(fn, accumulator)).value;\n    },\n\n    /**\n    .scan(fn, initial)\n    Calls `fn(current, value)` for each `value` in the stream. Where `fn`\n    returns a value it is pushed downstream, and `current` assumes that value\n    on the next iteration. Where `fn` returns `undefined` nothing is pushed and\n    `current` remains unchanged.\n    **/\n    scan: function(fn, initial) {\n        return new Scan(this, fn, initial);\n    },\n\n    /**\n    .slice(n, m)\n    Returns a stream of the nth to mth values of stream.\n    **/\n    slice: function(n, m) {\n        return new Slice(this, n, m);\n    },\n\n    /**\n    .split(n)\n    **/\n    split: function(n) {\n        return new Split(this, n);\n    },\n\n    /**\n    .start()\n    Out of the box, `.start()` does nothing. Actually, it errors if a '.start()'\n    is not implemented at the head of the stream. The method is provided as a\n    way to build timed streams. It echoes its arguments to the stream head\n    `.start()`, so the head determines whether `.start()` is supported.\n    **/\n    start: function() {\n        if (this.status === 'done') { return this; }\n        this[-1].start.apply(this[-1], arguments);\n        return this;\n    },\n\n    /**\n    .stop()\n    Stops the stream.\n    **/\n    stop: function() {\n        // Check status\n        if (this.status === 'done') { return this; }\n\n        // Does input have more than 1 output? ie, is it a multicast or\n        // broadcast stream? Don't stop it, unpipe() this from it, and\n        // stop `this`.\n        if (this[-1][1]) {\n            unpipe(this[-1], this);\n            return stop(this);\n        }\n\n        // Otherwise delegate stop() up the chain\n        this[-1].stop.apply(this[-1], arguments);\n        return this;\n    },\n\n    /**\n    .done(fn)\n    Cues `fn` to be called when the stream is stopped.\n    **/\n    done: function(listener) {\n        // Is stream already stopped? Call listener immediately.\n        if (this.status === 'done') {\n            call(listener);\n            return this;\n        }\n\n        const listeners = this[$listeners] || (this[$listeners] = []);\n        listeners.push(listener);\n        return this;\n    },\n\n    /* Experimental async iterator support for `for await (x of stream)`\n       loops. */\n    [Symbol.asyncIterator]: async function*() {\n        // Buffer for synchronous values\n        const values = [];\n        let push = (value) => values.push(value);\n\n        function setResolve(res, rej) {\n            push = res;\n        }\n\n        this\n        .each((value) => push(value))\n        .done(() => push = noop);\n\n        while (push !== noop) {\n            yield values.length ?\n                // Yield collected synchronous value\n                values.shift() :\n                // Yield next asynchronous value\n                await new Promise(setResolve) ;\n        }\n    }\n});\n\n\n/*\nBroadcast(pipeable, options)\nA Broadcast stream may be piped to multiple outputs. The options object has\nthe optional properties:\n\n```js\n{\n    // Remember and send the latest value to newly attached pipes\n    memory: true,\n\n    // Start the stream immediately, and keep it alive after output streams are\n    // removed, allowing you to attach new outputs. This stream can only be\n    // stopped by explicitly calling `.stop()` on it. TODO: is this still true\n    // in Stream v3?\n    hot: true\n}\n```\n*/\n\nexport function Broadcast(pipeable, options) {\n    //Stream.apply(this, arguments);\n    this[-1] = pipeable;\n\n    // Mark this stream as a memory stream\n    this.memory = !!(options && options.memory);\n\n    // Open the stream immediately and keep it live even without outputs by\n    // sending output 0 to nothing. It can now only be stopped by explicitly\n    // calling .stop() on it, and not by stopping child streams.\n    if (options && options.hot) {\n        this.pipe({ push: noop });\n    }\n}\n\nBroadcast.prototype = assign(create(Stream.prototype), {\n    push: function(value) {\n        // Reject undefined\n        if (value === undefined) { return; }\n\n        // If this is a memory stream keep value\n        if (this.memory) {\n            this.value = value;\n        }\n\n        let n = -1;\n        while (this[++n]) {\n            // TODO: should this push cause a child to .stop() and remove\n            // itself... we have a problem...\n            this[n].push(value);\n        }\n    },\n\n    pipe: function(output) {\n        let n = -1;\n        while (this[++n]);\n\n        // If this is a memory stream and this is the first output, flush the\n        // pipe. But we don't have any outputs yet! I know, but the latest value\n        // is remembered and it gets pushed to output below.\n        if (this.memory && n === 0) {\n            this[-1].pipe(this);\n        }\n\n        if (output.stop && output !== nothing) { output[-1] = this; }\n        this[n] = output;\n\n        // If stream has value already, it is a memory stream\n        if (this.value !== undefined) {\n            output.push(this.value);\n        }\n\n        // If not a memory stream and this is the first output start the pipeline\n        if (!this.memory && n === 0) {\n            this[-1].pipe(this);\n        }\n\n        return output;\n    }\n});\n\n\n/* Each() */\n\nfunction Each(input, fn) {\n    this[-1] = input;\n    this.push  = fn;\n}\n\nEach.prototype = assign(create(Stream.prototype), {\n    // Each is a consumer\n    pipe: null\n});\n\n\n/* Filter() */\n\nfunction Filter(input, fn) {\n    this[-1] = input;\n    this.fn    = fn;\n}\n\nFilter.prototype = assign(create(Stream.prototype), {\n    push: function filter(value) {\n        const fn = this.fn;\n        const is = fn(value);\n        is && this[0].push(value);\n    }\n});\n\n\n/* FlatMap() */\n\nfunction FlatMap(input, fn) {\n    this[-1] = input;\n    this.fn    = fn;\n}\n\nFlatMap.prototype = assign(create(Stream.prototype), {\n    push: function flatMap(value) {\n        const fn     = this.fn;\n        const values = fn(value);\n\n        if (values === undefined) { return; }\n\n        // Flatten array or array-like\n        if (isIterable(values)) {\n            for (const value of values) {\n                this[0].push(value);\n            }\n        }\n        // Flatten stream\n        else if (values.pipe) {\n            console.warn('FlatMapping pipeables is dodgy. Map to arrays for the moment please.');\n            // Todo: support flattening of streams. This method is crude -\n            // it does not preserve order, for one thing. Should streams be\n            // made iterable? CAN streams be made iterable? They'd have to\n            // be async...\n            this.done(values.each((value) => this[0].push(value)));\n            // This causes problems if you try\n            // stream.scan(...).flatMap(...)\n            //values.pipe(this[0]);\n        }\n        // Flatten promise\n        else if (values.then) {\n            values.then((value) => this[0].push(value));\n        }\n    }\n});\n\n\n/* Map() */\n\nfunction Map(input, fn) {\n    this[-1] = input;\n    this.fn    = fn;\n}\n\nMap.prototype = assign(create(Stream.prototype), {\n    push: function map(value) {\n        const fn     = this.fn;\n        const result = fn(value);\n        // Reject undefined, return false... why?\n        return result === undefined || !this[0] ?\n            false :\n            this[0].push(result) ;\n    }\n});\n\n\n/* Reduce() */\n\nfunction Reduce(fn, accumulator) {\n    this.fn    = fn;\n    this.value = accumulator;\n    this.i     = 0;\n}\n\nReduce.prototype = assign(create(Stream.prototype), {\n    push: function(value) {\n        const fn = this.fn;\n        this.value = fn(this.value, value, this.i++, this);\n    }\n});\n\n\n/* Scan() */\n\nfunction Scan(input, fn, accumulator) {\n    this[-1] = input;\n    this.fn    = fn;\n    this.value = accumulator;\n}\n\nScan.prototype = assign(create(Stream.prototype), {\n    push: function(value) {\n        const fn = this.fn;\n        this.value = fn(this.value, value);\n        this[0].push(this.value);\n    }\n});\n\n\n/* Slice() */\n\nfunction Slice(input, n, m = Infinity) {\n    if (window.DEBUG && (typeof n !== 'number' || n < 0)) {\n        throw new Error('Stream: .slice() requires a positive integer (' + n + ')');\n    }\n\n    if (window.DEBUG && (typeof m !== 'number' || m < 1)) {\n        throw new Error('Stream: .slice() requires a non-zero positive integer (n, ' + n + ')');\n    }\n\n    this[-1]    = input;\n    this.index    = -n;\n    this.indexEnd = n + m;\n}\n\nSlice.prototype = assign(create(Stream.prototype), {\n    push: function take(value) {\n        if (++this.index > 0) {\n            this[0].push(value);\n        }\n\n        if (this.index === this.indexEnd) {\n            this.stop();\n        }\n    }\n});\n\n\n/* Split(input, fn) */\n\nfunction Split(input, fn) {\n    this[-1] = input;\n    this.chunk = [];\n\n    if (typeof n === 'number') {\n        this.n = fn;\n    }\n    else {\n        this.fn = fn;\n    }\n}\n\nSplit.prototype = assign(create(Stream.prototype), {\n    fn: function() {\n        return this.chunk.length === this.n;\n    },\n\n    push: function map(value) {\n        const chunk = this.chunk;\n\n        if (this.fn(value)) {\n            // Emit complete chunk and create a new chunk\n            this[0].push(chunk);\n            this.chunk = [];\n        }\n        else {\n            // Push to existing chunk\n            chunk.push(value);\n        }\n    }\n});\n", "\nimport nothing from '../nothing.js';\nimport Stream, { pipe, stop } from './stream.js';\n\nconst A      = Array.prototype;\nconst assign = Object.assign;\nconst create = Object.create;\n\n\n/*\nBufferStream(values)\nA BufferStream may be pushed to before it is piped, as it starts life\nwith an array buffer of values.\n*/\n\nfunction notUndefined(value) {\n    return value !== undefined;\n}\n\nexport default function BufferStream(values) {\n    this.buffer = values ? values : [] ;\n}\n\nBufferStream.prototype = assign(create(Stream.prototype), {\n    pipe: function(output) {\n        // Connect stream to output\n        pipe(this, output);\n\n        // Empty buffer into stream. Stream may be stopped during this loop so\n        // check for `this[0]`.\n        while(this.buffer.length && this[0]) {\n            let value = A.shift.apply(this.buffer);\n            if (value !== undefined) {\n                this[0].push(value);\n            }\n        }\n\n        // Swap buffer for output, values are now pushed straight into output\n        this.buffer = output;\n        return output;\n    },\n\n    push: function(value) {\n        // .push() will buffer values even before .pipe() has set up the stream\n        if (value === undefined) { return; }\n        return this.buffer.push(value);\n    },\n\n    stop: function() {\n        if (this[-1]) {\n            return Stream.prototype.stop.apply(this, arguments);\n        }\n\n        this.buffer = nothing;\n        return stop(this);\n    }\n});\n", "\nimport Stream, { pipe, stop } from './stream.js';\n\nconst assign = Object.assign;\nconst create = Object.create;\n\n\n/**\nPromiseStream(promise)\n**/\n\nexport default function PromiseStream(promise) {\n    this.promise = promise;\n}\n\nPromiseStream.prototype = assign(create(Stream.prototype), {\n    push: null,\n\n    pipe: function(output) {\n        const promise = this.promise;\n\n        pipe(this, output);\n\n        // Do not chain .then() and .finally(), fire them in the same tick\n        promise.then((value) => {\n            if (this.status === 'done') { return; }\n            this[0].push(value);\n        });\n\n        promise.finally(() => stop(this));\n\n        return output;\n    }\n});\n", "\n\n/**\nCombineStream(object, options)\nCreates a stream of objects containing the latest values of all streams and\npromises in `object`, as soon as they become active or resolved.\n\n```js\nnew CombineStream({ a: stream, b: promise }).each((object) => {\n    // object.a and object.b are values\n});\n```\n\nIf `object` contains properties that are not streams or promises, those are\nalso set on streamed objects.\n\n```js\nnew CombineStream({ a: stream, b: promise, c: 5 }).each((object) => {\n    // object.c is 5\n});\n```\n\nOutput objects are created using the constructor of the input `object`,\nmaking it possible to use an array or other object as input and expect an\narray or other object as output.\n\n```js\nnew CombineStream([promise, stream]).each((object) => {\n    // object is an Array\n});\n```\n\nThe stream may be made mutable by passing in an options object with\n`mutable` set to `true`. In this case no new objects are constructed,\ninstead the input `object` is mutated and pushed to the output stream.\n\n```js\nnew CombineStream({ a: stream, b: promise }, { mutable: true }).each((object) => {\n    // object is the input object\n});\n```\n**/\n\nimport noop from '../noop.js';\nimport Stream, { pipe, stop } from './stream.js';\nimport PromiseStream from './promise-stream.js';\n\nconst assign = Object.assign;\nconst create = Object.create;\n\n\n/*\nPipe()\n*/\n\nfunction isActive(object) {\n    return !!object.active;\n}\n\nfunction isStopped(object) {\n    return !!object.stopped;\n}\n\nfunction Pipe(input, name, stream, values, pipes) {\n    this[-1] = input.then ?\n        // Turn promise into a stream\n        new PromiseStream(input) :\n        input ;\n\n    this.stream  = stream;\n    this.values  = values;\n    this.pipes   = pipes;\n    this.name    = name;\n    this.active  = false;\n    this.stopped = false;\n}\n\nassign(Pipe.prototype, {\n    push: function(value) {\n        const { stream, values, name } = this;\n        values[name] = value;\n        this.active  = true;\n        if (stream.active || (stream.active = this.pipes.every(isActive))) {\n            if (stream.mutable) {\n                stream[0].push(values);\n            }\n            else {\n                // Assign to new object in order to produce non-duplicates\n                const object = new this.values.constructor();\n                stream[0].push(assign(object, values));\n            }\n        }\n    },\n\n    // This is not part of the stop chain\n    stop: function() {\n        this.stopped = true;\n        // Stop stream when all inputs are stopped\n        if (this.pipes.every(isStopped)) {\n            stop(this.stream);\n        }\n    }\n});\n\n\n/*\nCombineStream()\n*/\n\nexport default function CombineStream(inputs, options) {\n    this.inputs  = inputs;\n    this.mutable = options && (options === true || options.mutable);\n    this.active  = false;\n}\n\nCombineStream.prototype = assign(create(Stream.prototype), {\n    push: null,\n\n    pipe: function(output) {\n        const inputs = this.inputs;\n        const pipes  = this.pipes = [];\n        let pipeable;\n\n        pipe(this, output);\n\n        // Populate pipes\n        let name;\n        for (name in inputs) {\n            const input = inputs[name];\n            if (typeof input === 'object' && (input.pipe || input.then)) {\n                pipes.push(new Pipe(input, name, this, inputs, pipes));\n            }\n        }\n\n        // Listen to inputs\n        for (pipeable of pipes) {\n            pipeable[-1]\n            // Will call pipeable.stop()\n            .done(pipeable)\n            // Will call pipeable.push()\n            .pipe(pipeable);\n        }\n\n        return output;\n    },\n\n    stop: function() {\n        // Check status\n        if (this.status === 'done') { return this; }\n\n        // Stop all inputs\n        this.pipes.forEach((pipeable) => {\n            const input = pipeable[-1];\n\n            // Does input have more than 1 output? Don't stop it, unpipe()\n            // this from it.\n            if (input[1]) {\n                unpipe(input, pipeable);\n            }\n            else {\n                // Don't pass arguments up the stop chain\n                input.stop();\n            }\n        });\n\n        // Stopping the last input stopped this stream already\n        return this;\n    }\n});\n", "\nimport Stream, { pipe, stop } from './stream.js';\n\nconst assign = Object.assign;\nconst create = Object.create;\n\n\n/*\nSource()\n*/\n\nfunction Source(stream) {\n    this.stream = stream;\n}\n\nassign(Source.prototype, {\n    push: function(value) {\n        this.stream[0].push(value);\n    },\n\n    stop: function() {\n        // Stop stream when all inputs are stopped\n        if (--this.stream.count === 0) {\n            stop(this.stream);\n        }\n    },\n\n    done: function(stopable) {\n        this.stream.done(stopable);\n    }\n});\n\n\n/*\nMergeStream\n*/\n\nexport default function MergeStream(inputs) {\n    this.inputs = inputs;\n}\n\nMergeStream.prototype = assign(create(Stream.prototype), {\n    push: null,\n\n    pipe: function(output) {\n        const inputs = this.inputs;\n        this.count = inputs.length;\n\n        // As in Stream.prototype.pipe()\n        pipe(this, output);\n\n        // Listen to inputs\n        const source = new Source(this);\n\n        let i = -1;\n        let input;\n        while (input = inputs[++i]) {\n            if (input.pipe) {\n                // Input is a stream\n                input.pipe(source);\n            }\n            else if (input.then) {\n                // Input is a promise. Do not chain .then() and .finally(),\n                // they must fire in the same tick\n                input.then((value) => source.push(value));\n                input.finally(() => source.stop());\n            }\n            else {\n                // Input is an array-like\n                let n = -1;\n                while (++n < input.length) {\n                    source.push(input[n]);\n                }\n                source.stop();\n            }\n        }\n\n        return output;\n    }\n});\n", "\nimport Stream, { pipe, stop } from './stream.js';\n\nconst assign = Object.assign;\nconst create = Object.create;\n\n/*\nClockStream(duration)\n\nIf `duration` is a number, constructs a stream of DOM timestamps at `duration`\nseconds apart.\n\nIf `duration` is `\"frame\"`, constructs a stream of DOM timestamps at the\nanimation frame rate.\n\nA ClockStream requires an explicit call to `.start()` to make it play. The\n`.start()` method optionally accepts a `startTime` parameter.\n*/\n\n\nexport default function ClockStream(duration) {\n    this.duration = duration;\n    this.timer    = undefined;\n    this.status   = 'idle';\n}\n\nClockStream.prototype = assign(create(Stream.prototype), {\n    push: null,\n\n    pipe: function(output) {\n        return pipe(this, output);\n    },\n\n    start: function(startTime) {\n        if (this.status !== 'idle') {\n            return this;\n        }\n\n        this.status = 'waiting';\n\n        if (this.duration === 'frame') {\n            const fn = (time) => {\n                this.timer = requestAnimationFrame(fn);\n                this[0].push(time / 1000);\n            };\n\n            // Start producing values\n            this.timer = requestAnimationFrame(fn);\n            // OR, for immediate start\n            //fn(performance.now());\n        }\n        else {\n            const time = performance.now() / 1000;\n\n            // Wait until startTime, or where startTime is undefined, next tick\n            this.timer = setTimeout(() => {\n                const time = performance.now() / 1000;\n                const fn = () => this[0].push(performance.now() / 1000);\n\n                // Push time and start interval timer\n                this.status = 'playing';\n                this[0].push(time);\n                this.timer = setInterval(fn, this.duration * 1000);\n            }, (time > startTime ? startTime - time : 0));\n        }\n\n        return this;\n    },\n\n    stop: function(sendStopFrame) {\n        // Already stopped?\n        if (this.status === 'done') {\n            return this;\n        }\n\n        // Cancel next frame\n        if (this.duration === 'frame') {\n            cancelAnimationFrame(this.timer);\n        }\n        // Cancel waiting timeout\n        else if (this.status === 'waiting') {\n            clearTimeout(this.timer) ;\n        }\n        // Cancel playing interval\n        else {\n            clearInterval(this.timer) ;\n        }\n\n        this.timer  = undefined;\n        return stop(this);\n    }\n});\n", "\nimport Stream     from './stream.js';\nimport TimeStream from './clock-stream.js';\n\nconst assign  = Object.assign;\nconst create  = Object.create;\n\n\n/** Throttle(stream, frames) **/\n\nexport default function Throttle(input, duration) {\n    Stream.call(this, input);\n    this.duration = duration;\n}\n\nThrottle.prototype = assign(create(Stream.prototype), {\n    push: function(value) {\n        // If no value\n        if (value === undefined) {\n            return;\n        }\n\n        // If clock is running\n        if (this.clock) {\n            // Store latest value\n            this.value = value;\n            return;\n        }\n\n        const clock = new TimeStream(this.duration);\n        const fn = (time) => {\n            // If no value has been pushed since the last one stop the clock\n            if (this.value === undefined) {\n                clock.stop();\n                this.clock = undefined;\n                return;\n            }\n\n            // Push the latest value to output\n            this[0].push(this.value);\n            this.value = undefined;\n        };\n\n\n        this.value = value;\n        this.clock = clock.each(fn).start();\n    },\n\n    stop: function(sendLastValue) {\n        // Stop the frames stream\n        if (this.clock) {\n            this.clock.stop();\n            this.clock = undefined;\n        }\n\n        if (sendLastValue) {\n            this[0].push(value);\n            this.value = undefined;\n        }\n\n        Stream.prototype.stop.apply(this, arguments);\n        return this;\n    }\n});\n", "\nimport Signal, { hasInput } from '../signal.js';\nimport Stream, { pipe }     from './stream.js';\n\nconst assign = Object.assign;\nconst create = Object.create;\nconst S      = Stream.prototype;\n\nfunction evaluate() {\n    return this.signal.value;\n}\n\nexport default function SignalStream(signal, initial) {\n    this.signal  = signal;\n    this.initial = initial;\n}\n\nSignalStream.prototype = assign(create(Stream.prototype), {\n    push: null,\n\n    invalidate: function(signal) {\n        if (this.status === 'done') return;\n\n        // Verify that signal has the right to invalidate this\n        if (signal && !hasInput(this, signal)) return;\n\n        // Clear inputs\n        let n = 0;\n        while (this[--n]) this[n] = undefined;\n\n        // Evaluate and send value to consumer on next tick\n        promise.then(() =>  S.push.apply(this, Signal.evaluate(this, evaluate)));\n    },\n\n    pipe: function(output) {\n        // Set up dependency graph, return value\n        const value = Signal.evaluate(this, evaluate);\n        pipe(this, output);\n\n        // Run the observer if value is not initial\n        if (value !== initial) S.push.apply(this, value);\n\n        return output;\n    }\n});\n", "\nimport nothing           from './nothing.js';\nimport self              from './self.js';\nimport Data              from './data.js';\n\nimport Stream, { Broadcast, pipe, stop } from './stream/stream.js';\nimport BufferStream      from './stream/buffer-stream.js';\nimport CombineStream     from './stream/combine-stream.js';\nimport MergeStream       from './stream/merge-stream.js';\nimport PromiseStream     from './stream/promise-stream.js';\nimport FrameStream       from './stream/clock-stream.js';\nimport Throttle          from './stream/throttle-stream.js';\nimport SignalStream      from './stream/signal-stream.js';\n\nconst A      = Array.prototype;\nconst assign = Object.assign;\n\n\nfunction throwTypeError(source) {\n    throw new TypeError('Stream cannot be created .from() ' + typeof source);\n}\n\nassign(Stream, {\n    /**\n    Stream.isStream(object)\n    Checks `object`'s prototype and returns `true` or `false`.\n    **/\n    isStream: function(object) {\n        return Stream.prototype.isPrototypeOf(object);\n    },\n\n    /**\n    Stream.of(value1, value2, ...)\n    Creates a pushable BufferStream from the given parameters.\n    **/\n    of: function() {\n        return new BufferStream(A.slice.apply(arguments));\n    },\n\n    /**\n    Stream.from(source)\n    Creates a stream from `source`, which may be an **array** (or array-like),\n    a **promise**, a **function**, a **producer** (an object with `.pipe()` and\n    `.stop()` methods), or an **object** of streams, promises or values.\n    **/\n    from: function(source) {\n        return !source ? throwTypeError(source) :\n            // Source is an object\n            typeof source === 'object' ?\n                // Source is a stream or producer\n                typeof source.pipe === 'function' ? new Stream(source) :\n                // Source is a promise\n                typeof source.then === 'function' ? new PromiseStream(source) :\n                // Source is an array or array-like\n                typeof source.length === 'number' ? new BufferStream(source) :\n                // Source is a Signal\n                Signal.isSignal(source) ? new SignalStream(signal) :\n                // Source is an object of streams, promises and values\n                new CombineStream(source) :\n            // Source is a function\n            typeof source === 'function' ? new Stream(source) :\n            // Source cannot be made into a stream\n            throwTypeError(source) ;\n    },\n\n    observe: function(path, object, initial) {\n        return new SignalStream(Data.signal(path, object), initial);\n    },\n\n    /*\n    Stream.broadcast(options)\n    Returns a broadcast stream. Methods called on this stream each\n    create a new stream.\n    */\n    broadcast: (options) => new Broadcast(nothing, options),\n\n    /**\n    Stream.combine(inputs)\n    Creates a stream of objects containing the latest values of all streams and\n    promises in `inputs` as they resolve:\n\n    ```js\n    Stream.combine({ a: stream, b: promise }).each((object) => {\n        // object.a and object.b are values\n    });\n    ```\n\n    If `inputs` contains properties that are not streams or promises, those are\n    also set on streamed objects:\n\n    ```js\n    Stream.combine({ a: stream, c: 5 }).each((object) => {\n        // object.c is 5\n    });\n    ```\n\n    By default immutable â€“ the stream emits new objects â€“ it can be made to\n    emit a mutated `inputs` object instead, by passing an options object with\n    `mutable` set to `true` as a second parameter. This can help minimise\n    garbage collection when dealing with large streams, but emitted objects\n    are only valid to be consumed synchronously, as the next emitted object is\n    actually the same object.\n\n    ```js\n    Stream\n    .combine({ a: stream, b: promise }, { mutable: true })\n    .each((object) => {\n        // object is the input object, properties a and b are now values\n    });\n    ```\n\n    Output objects are created using the constructor of the input `object`,\n    making it possible to use an array or other object as input and expect an\n    array or other object as output.\n\n    ```js\n    Stream.combine([promise, stream]).each((object) => {\n        // object is an Array\n    });\n    ```\n    **/\n    combine: (object, options) => new CombineStream(object, options),\n\n    /**\n    Stream.clock(duration)\n\n    If `duration` is a number, constructs an interval stream of DOM timestamps\n    at `duration` seconds apart.\n\n    If `duration` is `\"frame\"`, constructs a stream of DOM timestamps from\n    `requestAnimationFrame`.\n    **/\n    clock: (duration) => new FrameStream(duration),\n\n    /**\n    Stream.merge(stream1, stream2, ...)\n    Creates a stream by merging values from any number of input streams into a\n    single output stream. Values are emitted in the time order they are received\n    from inputs.\n\n    ```js\n    Stream.merge(stream1, stream2).each((value) => {\n        // value is from stream1 or stream 2\n    });\n    ```\n    **/\n    merge: function() { return new MergeStream(arguments); },\n\n    /**\n    Stream.throttle(time)\n    **/\n    throttle: function(time) {\n        return new Throttle(null, time);\n    }\n});\n\nassign(Stream.prototype, {\n    /**\n    .throttle(time)\n    **/\n    throttle: function(time) {\n        return new Throttle(this, time);\n    },\n\n    /**\n    Stream.merge(stream1, stream2, ...)\n    Creates a stream by merging values from any number of input streams into a\n    single output stream. Values are emitted in the time order they are received\n    from inputs.\n\n    ```js\n    Stream.merge(stream1, stream2).each((value) => {\n        // value is from stream1 or stream 2\n    });\n    ```\n    **/\n    log: (window.DEBUG && window.console) ?\n        function log(...parameters) {\n            return this.map((value) => (console.log(...parameters, value), value))\n        } :\n        self\n});\n\nconst frames = Stream.frames;\n\nexport {\n    Stream as default,\n    pipe,\n    stop,\n    frames\n};\n", "\n/**\nevents(type, element)\n\nReturns a mappable stream of events heard on `element`.\n\n```js\nevents('click', element)\n.map((e) => e.target.id)\n```\n\nThe first parameter may alternatively be a select object. It must have a\n`.type` property.\n\n```js\nevents({ type: 'click' }, element)\n.map((e) => e.target.id)\n```\n\nThe object may contain a number of other properties that select the events\nreceived. It supports the standard addEventListener options, for passive and\ncapture phase event binding.\n\n```js\nevents({ type: 'scroll', passive: true, capture true }, window)\n.map((e) => window.scrollTop)\n```\n\nAnd a `.select` property, a CSS selector, that filters events to those with\ntargets that match or have a `closest()` ancestor that matches the selector.\n\n```js\nevents({ type: 'click', select: '[name=\"button\"]' }, element)\n.map((e) => e.target.id)\n```\n\nHowever, if you need to delegate events it is recommended to use the\n`delegate()` function, which has the added benefit of direct access to the\ndelegated target.\n\n```js\nevents('click', element)\n.each(delegate({\n    '[name=\"button\"]': (target, e) => console.log(target.id),\n    '[name=\"remove\"]': (target, e) => document.getElementById(target.value).remove(),\n    ...\n}))\n```\n\nStopping an event stream removes its event listeners.\n\n```js\nevents('click', element).stop()\n```\n**/\n\n/*\nevents(type, element, initial)\n\nPass in an `initial` event object to have the event stream start synchronously\nwith an initial value when consumed.\n*/\n\nimport cache  from 'fn/cache.js';\nimport Stream, { pipe, stop } from 'fn/stream.js';\n\nconst assign  = Object.assign;\nconst rspaces = /\\s+/;\nconst types   = {\n    fullscreenchange: cache(() => (\n        'fullscreenElement' in document ? 'fullscreenchange' :\n        'webkitFullscreenElement' in document ? 'webkitfullscreenchange' :\n        'mozFullScreenElement' in document ? 'mozfullscreenchange' :\n        'msFullscreenElement' in document ? 'MSFullscreenChange' :\n        'fullscreenchange'\n    ))\n};\n\n\n// DOM click events may be simulated on inputs when their labels are\n// clicked. The tell-tale is they have the same timeStamp. Track click\n// timeStamps.\nvar clickTimeStamp = 0;\n\nwindow.addEventListener('click', (e) => clickTimeStamp = e.timeStamp);\n\nfunction listen(listener, type) {\n    listener.node.addEventListener(types[type] ? types[type]() : type, listener, listener.options);\n    return listener;\n}\n\nfunction unlisten(listener, type) {\n    listener.node.removeEventListener(types[type] ? types[type]() : type, listener);\n    return listener;\n}\n\nfunction EventsProducer(type, options, node, initialEvent) {\n    // Potential hard-to-find error here if type has repeats, ie 'click click'.\n    // Lets assume nobody is dumb enough to do this, I dont want to have to\n    // check for that every time.\n    this.types        = type.split(rspaces);\n    this.options      = options;\n    this.node         = node;\n    this.select       = options && options.select;\n    this.initialEvent = initialEvent;\n}\n\nassign(EventsProducer.prototype, {\n    pipe: function(output) {\n        pipe(this, output);\n        this.types.reduce(listen, this);\n\n        if (this.initialEvent) {\n            this.handleEvent(this.initialEvent);\n            delete this.initialEvent;\n        };\n    },\n\n    handleEvent: function(e) {\n        // Ignore clicks with the same timeStamp as previous clicks â€“\n        // they are likely simulated by the browser, like how clicks on labels\n        // cause simulated clicks to be emitted from inputs\n        if (e.type === 'click' && e.timeStamp <= clickTimeStamp) {\n            return;\n        }\n\n        // If there is a selector and the target doesn't match, shoofty\n        // outta here\n        if (this.select) {\n            const selectedTarget = e.target.closest(this.select);\n            if (!selectedTarget) { return; }\n            e.selectedTarget = selectedTarget;\n        }\n\n        this[0].push(e);\n    },\n\n    stop: function() {\n        this.types.reduce(unlisten, this);\n        stop(this[0]);\n    }\n});\n\nexport default function events(type, node, initialEvent) {\n    let options;\n\n    if (typeof type === 'object') {\n        options = type;\n        type    = options.type;\n    }\n\n    return new Stream(new EventsProducer(type, options, node, initialEvent));\n}\n", "import curry from './curry.js';\n\n/**\nparseValue(units, string)\n\nParse `string` as a value with a unit (such as `\"3px\"`). Parameter `units` is an\nobject of functions keyed by the unit postfix. It may also have a `catch`\nfunction.\n\n```js=\nconst parseUnitValue = parseValue({\n    px: function(n) {\n        return n;\n    },\n\n    catch: function(string) {\n        throw new Error('Cannot parse px value');\n    }\n});\n```\n**/\n\n// Be generous in what we accept, space-wise, but exclude spaces between the\n// number and the unit\nconst runit = /^\\s*([+-]?\\d*\\.?\\d+)([^\\s]*)\\s*$/;\n\nexport default function parseValue(units) {\n    return function parseValue(string) {\n        // Allow number to pass through\n        if (typeof string === 'number') {\n            return string;\n        }\n\n        var entry = runit.exec(string);\n\n        if (!entry || !units[entry[2] || '']) {\n            if (!units.catch) {\n                throw new Error('Cannot parse value \"' + string + '\" (accepted units ' + Object.keys(units).join(', ') + ')');\n            }\n\n            return entry ?\n                units.catch(parseFloat(entry[1]), entry[2]) :\n                units.catch(parseFloat(string)) ;\n        }\n\n        return units[entry[2] || ''](parseFloat(entry[1]));\n    };\n}\n", "\n/**\ntoRad(deg)\n**/\n\nexport default (n) => n * Math.PI / 180;\n", "\nimport id         from './id.js';\nimport parseValue from './parse-value.js';\nimport toRad      from './to-rad.js';\n\n/**\nparseAngle(string)\nParses strings of the form `'45deg'`, `'0rad'` or `'0.5turn'`. Returns a\nnumber in radians. If `string` is a number, it passes through.\n**/\n\nexport default parseValue({\n    deg:  toRad,\n    rad:  id,\n    turn: (n) => n * 2 * Math.PI,\n    catch: function(string) {\n        throw new Error('Cannot parse value \"' + string + '\"');\n    }\n});\n", "/**\nstyle(property, node)\n\nReturns the computed style `property` of `node`.\n    style('transform', node);  // returns transform\n*/\n\nimport parseAngle from 'fn/parse-angle.js';\n\nvar rpx    = /px$/;\nvar rangle = /deg$|turn$|rad$/;\n\nfunction computedStyle(name, node) {\n\treturn window.getComputedStyle ?\n\t\twindow\n\t\t.getComputedStyle(node, null)\n\t\t.getPropertyValue(name) :\n\t\t0 ;\n}\n\nexport default function style(name, node) {\n    var value = computedStyle(name, node);\n\n    // Pixel values are converted to number type\n    return typeof value === 'string' ?\n\t\trpx.test(value) ? parseFloat(value) :\n\t\trangle.test(value) ? parseAngle(value) :\n        value :\n\t\tvalue ;\n}\n", "// Units\n\nimport id         from 'fn/id.js';\nimport overload   from 'fn/overload.js';\nimport toType     from 'fn/to-type.js';\nimport parseValue from 'fn/parse-value.js';\nimport style      from './style.js';\n\n\n/* Track document font size */\n\nlet emSize;\nlet remSize;\n\nfunction getEmSize() {\n    if (!emSize) {\n        if (window.DEBUG) {\n            console.warn('Calculating root em value may cause reflow as user font-size cannot be known without setting <html style=\"font-size: 100%;\">');\n        }\n\n        const styledFontSize = document.documentElement.style.fontSize;\n        document.documentElement.style.fontSize = '100%';\n        emSize = style(\"font-size\", document.documentElement);\n        document.documentElement.style.fontSize = styledFontSize || '';\n    }\n\n    return emSize;\n}\n\nfunction getRemSize() {\n    if (!remSize) {\n        remSize = style(\"font-size\", document.documentElement);\n    }\n\n    return remSize;\n}\n\nwindow.addEventListener('resize', () => {\n    emSize  = undefined;\n    remSize = undefined;\n});\n\n/**\npx(value)\nTakes a number in pixels or a string of the form `'10px'`, `'10em'`, `'10rem'`,\n`'100vw'`, `'100vh'`, `'100vmin'` or `'100vmax'`, and returns a numeric value\nin pixels.\n*/\n\nexport const px = overload(toType, {\n    'number': id,\n\n    'string': parseValue({\n        px:   id,\n        em:   (n) => getEmSize() * n,\n        rem:  (n) => getRemSize() * n,\n        vw:   (n) => window.innerWidth * n / 100,\n        vh:   (n) => window.innerHeight * n / 100,\n\n        vmin: (n) => (\n            window.innerWidth < window.innerHeight ?\n                window.innerWidth * n / 100 :\n                window.innerHeight * n / 100\n        ),\n\n        vmax: (n) => (\n            window.innerWidth < window.innerHeight ?\n                window.innerHeight * n / 100 :\n                window.innerWidth * n / 100\n        )\n    })\n});\n\nexport default px;\n\n/**\nem(value)\nTakes numeric value in px, or CSS length of the form `'10px'`, and returns\na numeric value in `em`, eg. `0.625`. Depends on the user defined browser\n`font-size`.\n*/\n\nexport function em(n) {\n    return px(n) / getEmSize();\n}\n\n/**\nrem(value)\nTakes numeric value in px, or CSS length of the form `'10px'`, and returns\na numeric value in `rem`, eg. `0.625`. Depends on the `font-size` of the\ndocumentElement.\n*/\n\nexport function rem(n) {\n    return px(n) / getRemSize();\n}\n\n/**\nvw(value)\nTakes number in pixels or CSS length of the form `'10em'` and returns a\nnumeric value in `vw`, eg. `120`. Depends on the width of the viewport at\nrender time.\n*/\n\nexport function vw(n) {\n    return 100 * px(n) / window.innerWidth;\n}\n\n/**\nvh(value)\nTakes number in pixels or CSS length of the form `'10em'` and returns a\nnumeric value in `vh`, eg. `120`. Depends on the height of the viewport at\nrender time.\n*/\n\nexport function vh(n) {\n    return 100 * px(n) / window.innerHeight;\n}\n\n/**\nvmin(value)\nTakes number in pixels or CSS length of the form `'10em'` and returns a\nnumeric value in `vmin`, eg. `120`. Depends on the minimum dimension of the\nviewport at render time.\n*/\n\nexport function vmin(n) {\n    return 100 * px(n) / (\n        window.innerWidth < window.innerHeight ?\n            window.innerWidth :\n            window.innerHeight\n    );\n}\n\n/**\nvmax(value)\nTakes number in pixels or CSS length of the form `'10em'` and returns a\nnumeric value in `vmax`, eg. `120`. Depends on the maximum dimension of the\nviewport at render time.\n*/\n\nexport function vmax(n) {\n    return 100 * px(n) / (\n        window.innerWidth < window.innerHeight ?\n            window.innerHeight :\n            window.innerWidth\n    );\n}\n", "\n/**\ngestures(options, node)\n\nReturns a stream of streams of events. Each stream of events represents the\nmotion of a single finger. The types of events the stream contains is a\n`'pointerdown'` followed by any number of `'pointermove'`s and a `'pointerup'`\nor `'pointercancel'` event.\n\n```js\ngestures({ select: '.thing', threshold: '0.5rem', device: 'mouse pen touch' }, document.body)\n.each(function(events) { ... });\n```\n\nThe `options` object may optionally contain any of:\n\n```js\n{\n    // Listen to gestures on a given device type. Internally the pointer events'\n    // e.pointerType is matched against this string: it may contain any of the\n    // types 'pen', 'mouse' and 'touch'. Where not defined, all pointer types\n    // trigger a gesture\n    device: 'mouse pen',\n\n    // Listen to gestures inside a selected element or elements\n    select: '.class'\n\n    // Determine a minimum distance a finger must travel before a gesture is\n    // considered to have started. Defaults to 4px.\n    threshold: '0.25rem'\n}\n```\n\nIt is a Very Good Idea to style whatever element is being gestured with\n`touch-action` to avoid the browser sending `pointercancel` events when it\nthinks you are trying to perform some native pan or scroll\n([MDN touch-action](https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action))\n*/\n\nimport get             from 'fn/get.js';\nimport overload        from 'fn/overload.js';\nimport Stream, { pipe, stop } from 'fn/stream/stream.js';\nimport px              from './parse-length.js';\n\nconst A      = Array.prototype;\nconst assign = Object.assign;\n\nconst userSelect = 'webkitUserSelect' in document.body.style ?\n    'webkitUserSelect' :\n    'userSelect' ;\n\nconst store = {};\n\nexport const config = {\n    // Number of pixels, or string CSS length, that a pressed pointer travels\n    // before gesture is started.\n    threshold: 4,\n\n    ignoreTags: {\n        textarea: true,\n        input: true,\n        select: true\n    }\n};\n\nlet clickSuppressionTimestamp = -Infinity;\n\nfunction stopPropagation(e) {\n    if (e.timeStamp - clickSuppressionTimestamp > 60) { return; }\n    e.stopPropagation();\n    e.preventDefault();\n}\n\n/* Pointermove, pointerup and pointercancel handler */\n\nfunction distanceThreshold(distance, x, y) {\n    return (x * x + y * y) >= (distance * distance);\n}\n\nfunction Pointermove(stream, e, options) {\n    this.stream    = stream;\n    this.target    = e.gestureTarget;\n    this.events    = [e];\n    this.options   = options;\n    this.pointerId = e.pointerId;\n\n    if (typeof options.threshold === 'function') {\n        // options.threshold is a function\n        this.checkThreshold = options.threshold;\n    }\n    else {\n        // options.threshold is a string or number\n        const distance = px(options.threshold);\n        this.checkThreshold = (x, y, t) => distanceThreshold(distance, x, y, t);\n    }\n\n    document.addEventListener('pointermove', this);\n    document.addEventListener('pointerup', this);\n    document.addEventListener('pointercancel', this);\n}\n\nassign(Pointermove.prototype, {\n    handleEvent: overload(get('type'), {\n        'pointermove': function(e) {\n            // If it's not a move from this gesture's pointer we're not interested\n            if (this.pointerId !== e.pointerId) {\n                return;\n            }\n\n            // If pointer is already gesturing don't allow it to start another\n            if (this.pointerId in store && this !== store[this.pointerId]) {\n                this.stop();\n                return;\n            }\n\n            this.events.push(e);\n\n            if (!this.isGesture) {\n                // Check to see if we have satisfied the threshold check for\n                // x, y and time, if so start the gesture\n                const e0 = this.events[0];\n                const x  = e.clientX - e0.clientX;\n                const y  = e.clientY - e0.clientY;\n                const t  = (e.timeStamp - e0.timeStamp) / 1000;\n\n                if (this.checkThreshold(x, y, t)) {\n                    this.createGesture();\n                }\n            }\n        },\n\n        'pointerup': function(e) {\n            if (this.pointerId !== e.pointerId) {\n                return;\n            }\n\n            this.events.push(e);\n            this.target.releasePointerCapture(this.pointerId);\n            this.stop();\n\n            // Suppress click event that follows pointerup\n            if (this.isGesture) {\n                clickSuppressionTimestamp = e.timeStamp;\n                document.addEventListener('click', stopPropagation, {\n                    capture: true,\n                    once: true\n                });\n            }\n        },\n\n        'default': function(e) {\n            if (this.pointerId !== e.pointerId) {\n                return;\n            }\n\n            this.events.push(e);\n            this.target.releasePointerCapture(this.pointerId);\n            this.stop();\n        }\n    }),\n\n    createGesture: function() {\n        // We are gesturing! Let's go\n        this.isGesture = true;\n\n        // For the duration of us dragging the pointer around we need to\n        // prevent text selection on the document. Note doing this does not\n        // deselect any text that has already been selected.\n        this.userSelectState = document.body.style[userSelect];\n        document.body.style[userSelect] = 'none';\n\n        // Keep a record of which pointers are currently responsible for\n        // gestures - we only want one per pointer, max\n        store[this.pointerId] = this;\n\n        // Encourage pointer events for this pointerId to come from this\n        // element only\n        this.target.setPointerCapture(this.pointerId);\n\n        // Push a new gesture stream that uses this as producer\n        this.stream.push(new Stream(this));\n    },\n\n    pipe: function(output) {\n        // Sets this[0] and listens to stops on output\n        pipe(this, output);\n\n        // Empty buffer into stream\n        while(this.events.length) {\n            // Stream may be stopped during this loop so push to `this[0]`\n            // rather than to `output`\n            this[0].push(A.shift.apply(this.events));\n        }\n\n        // Have the output stream take over as the events buffer\n        this.events = output;\n    },\n\n    stop: function() {\n        // Remove the listeners\n        document.removeEventListener('pointermove', this);\n        document.removeEventListener('pointerup', this);\n        document.removeEventListener('pointercancel', this);\n\n        // Is it already stopped?\n        if (this.isGesture) {\n            // Reset text selectability\n            document.body.style[userSelect] = this.userSelectState;\n\n            // Remove record that keeps this pointerId bound to this gesture\n            delete store[this.pointerId];\n        }\n\n        if (this[0]) {\n            const output = this[0];\n            stop(output);\n        }\n    }\n});\n\n\n/* Pointerdown handler */\n\nfunction isIgnoreTag(e) {\n    var tag = e.target.tagName;\n    return tag && (!!config.ignoreTags[tag.toLowerCase()] || e.target.draggable);\n}\n\nfunction PointerProducer(node, options) {\n    this.node    = node;\n    this.options = options;\n}\n\nassign(PointerProducer.prototype, {\n    pipe: function(output) {\n        this[0] = output;\n        this.node.addEventListener('pointerdown', this);\n        return output;\n    },\n\n    handleEvent: function(e) {\n        // Ignore non-primary buttons\n        if (e.button !== 0) { return; }\n\n        // Check pointer type is in options\n        if (this.options.device && !this.options.device.includes(e.pointerType)) { return; }\n\n        // Ignore form and interactive elements\n        if (isIgnoreTag(e)) { return; }\n\n        // Check target matches selector\n        let gestureTarget = e.target;\n        if (this.options.select) {\n            gestureTarget = e.target.closest(this.options.select);\n            if (!gestureTarget) { return; }\n        }\n\n        // Copy event to keep the true target around, as target is mutated on\n        // the event if it passes through a shadow boundary after being handled\n        // here, causing a rare but very gnarly bug hunt.\n        var event = {\n            type:          e.type,\n            target:        e.target,\n            currentTarget: e.currentTarget,\n            gestureTarget: gestureTarget,\n            clientX:       e.clientX,\n            clientY:       e.clientY,\n            timeStamp:     e.timeStamp,\n            pointerId:     e.pointerId\n        };\n\n        new Pointermove(this[0], event, this.options);\n    },\n\n    // Stop the gestures stream\n    stop: function() {\n        if (this[0]) {\n            this.node.removeEventListener('pointerdown', this);\n            stop(this[0]);\n        }\n\n        return this;\n    }\n});\n\n\n/* Gestures */\n\nexport default function gestures(options, node) {\n    options = node ?\n        options ? assign({}, config, options) : config :\n        config ;\n\n    node = node ?\n        node :\n        options ;\n\n    if (window.DEBUG && options.selector) {\n        console.warn('gestures(options) deprecated options.selector, name changed to options.select');\n    }\n\n    return new Stream(new PointerProducer(node, options));\n}\n", "\n/**\nisPrimaryButton(e)\nReturns `true` if event is from the primary (normally the left or only)\nbutton of an input device. Use this to filter out right-clicks.\n*/\n\nexport default function isPrimaryButton(e) {\n    // Ignore mousedowns on any button other than the left (or primary)\n    // mouse button, or when a modifier key is pressed.\n    return (e.which === 1 && !e.ctrlKey && !e.altKey && !e.shiftKey);\n}\n", "\n/**\nrect(node)\n\nReturns a `DOMRect` object describing the draw rectangle of `node`.\n(If `node` is `window` a preudo-DOMRect object is returned).\n**/\n\nfunction windowBox() {\n\treturn {\n\t\tx:      0,\n\t\ty:      0,\n\t\tleft:   0,\n\t\ttop:    0,\n\t\tright:  window.innerWidth,\n\t\tbottom: window.innerHeight,\n\t\twidth:  window.innerWidth,\n\t\theight: window.innerHeight\n\t};\n}\n\nexport default function rect(node) {\n\treturn node === window ?\n\t\twindowBox() :\n        // In Safari SVG shapes dont get a .getClientRects()[0] so fallback to\n        // .getBoundingClientRect()\n\t\tnode.getClientRects()[0] || node.getBoundingClientRect() ;\n}\n", "\n/**\ntrigger(type, node)\n\nTriggers event of `type` on `node`. Returns `false` if the event default was\nprevented, otherwise `true`.\n\n```\ntrigger('activate', node);\n```\n\nAlternatively the first argument may be an object with a `type` property, and\noptionally `detail`, which must be an object, and `bubbles`, `cancelable` and\n`composed` options, which determine the behaviour of the event.\n\n```\ntrigger({\n    type:       'activate',\n    detail:     {...},\n    bubbles:    true,\n    cancelable: true,\n    composed:   false\n}, node);\n```\n**/\n\nimport curry from 'fn/curry.js';\n\nconst assign   = Object.assign;\n\nconst defaults = {\n    // The event bubbles (false by default)\n    // https://developer.mozilla.org/en-US/docs/Web/API/Event/Event\n    bubbles: true,\n\n    // The event may be cancelled (false by default)\n    // https://developer.mozilla.org/en-US/docs/Web/API/Event/Event\n    cancelable: true\n\n    // Trigger listeners outside of a shadow root (false by default)\n    // https://developer.mozilla.org/en-US/docs/Web/API/Event/composed\n    //composed: false\n};\n\nexport function trigger(type, node) {\n    let options = defaults;\n    let properties, detail, bubbles, cancelable, composed, event;\n\n    if (typeof type === 'object') {\n        ({ type, detail, bubbles, cancelable, composed, ...properties } = type);\n\n        // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent\n        // Options accepted by CustomEvent:\n        // detail:     any\n        // bubbles:    true | false\n        // cancelable: true | false\n        // composed:   true | false\n        event = assign(new CustomEvent(type, {\n            detail,\n            bubbles:    bubbles    || defaults.bubbles,\n            cancelable: cancelable || defaults.cancelable,\n            composed:   composed   || defaults.composed\n        }), properties);\n    }\n    else {\n        event = new CustomEvent(type, defaults);\n    }\n\n    return node.dispatchEvent(event);\n}\n\nexport default curry(trigger, true);\n", "\nexport const $data = Symbol('data');\n\nexport const config = {\n    minScrollInterval: 0.0375,\n    maxScrollInterval: 0.18\n};\n\n\n/*\nscrollInterval\nKeep a heuristic of the shortest 'safe' time between scroll events, used by\nscroll and swipe streams to determine when a scroll may have come to rest.\n*/\n\nlet scrollInterval = config.maxScrollInterval;\n\nexport function updateScrollInterval(times) {\n    // Dynamically adjust scrollInterval to tighten it up,\n    // imposing a baseline of config.minScrollInterval (0.0375s * 1.4)\n\n    let n = times.length;\n    let interval = 0;\n\n    while (--n) {\n        const t = times[n] - times[n - 1];\n        interval = t > interval ? t : interval;\n    }\n\n    interval = interval < config.minScrollInterval ?\n        config.minScrollInterval :\n        interval ;\n\n    scrollInterval = (1.4 * interval) > config.maxScrollInterval ?\n        config.maxScrollInterval :\n        (1.4 * interval) ;\n}\n\nexport function getScrollInterval() {\n    return scrollInterval;\n}\n", "\nexport default 'MozAppearance' in document.documentElement.style;\n", "\n/*\nDetect and scroll to active slides. The active is the slide currently in\nscroll-snap alignment.\n*/\n\nimport { px } from 'dom/parse-length.js';\nimport rect   from 'dom/rect.js';\nimport isFF   from 'dom/is-firefox.js';\n\n// FireFox resets scrollLeft to 0 on DOMContentLoaded. Naughty FireFox. We\n// can not feature detect this until it has happened, unfortunately, so we\n// are forced to use a browser hack `isFF`.\nlet DOMContentLoaded = false;\nif (isFF) {\n    document.addEventListener('DOMContentLoaded', (e) => DOMContentLoaded = true);\n}\n\nfunction getPaddedBox(slides) {\n    const box          = rect(slides);\n    const computed     = window.getComputedStyle(slides, null);\n\n    // TODO: These values may contain `calc()`, which won't parse. How do we get\n    // used or actual values out of CSS?\n    let paddingLeft, paddingRight;\n    try {\n        paddingLeft  = px(computed.getPropertyValue('padding-left'));\n        paddingRight = px(computed.getPropertyValue('padding-right'));\n    }\n    catch(e) {\n        console.warn(e.message);\n        paddingLeft  = 0;\n        paddingRight = 0;\n    }\n\n    box.leftPadding   = box.left + paddingLeft;\n    box.rightPadding  = box.left + box.width - paddingRight;\n    box.centrePadding = box.leftPadding + (box.width - paddingLeft - paddingRight) / 2;\n\n    return box;\n}\n\nfunction getSnapX(element) {\n    // Todo: do we need webkit property here?\n    const snap = window\n        .getComputedStyle(element, null)\n        .getPropertyValue('scroll-snap-align');\n\n    // Imagine a detection line half a slides' width to the right of\n    // the left, the centre, or the right...\n    return snap.endsWith('start') ? 'left' :\n        snap.endsWith('end')   ? 'right' :\n        'centre' ;\n}\n\nfunction scrollToTarget(slides, target, behavior) {\n    const slidesBox = getPaddedBox(slides);\n    const targetBox   = rect(target);\n    const snap        = getSnapX(target);\n\n    // Move scroll position to target slide, taking into account\n    // scroll-snap-align of the slide\n    const position = {\n        top:  slides.scrollTop,\n        left: slides.scrollLeft + (\n            snap === 'left' ? targetBox.left - slidesBox.leftPadding :\n            snap === 'right' ? targetBox.right - slidesBox.rightPadding :\n            targetBox.left + (targetBox.width / 2) - slidesBox.centrePadding\n        ),\n        behavior: behavior\n    };\n\n    slides.scrollTo(position);\n\n    // In Firefox, wait for DOMContentLoaded and set position again.\n    if (isFF && !DOMContentLoaded) {\n        document.addEventListener('DOMContentLoaded', () => slides.scrollTo(position));\n    }\n}\n\nexport function scrollTo(slides, target) {\n    scrollToTarget(slides, target, 'smooth');\n    return target;\n}\n\nexport function jumpTo(slides, target) {\n    slides.style.setProperty('scroll-behavior', 'auto', 'important');\n    scrollToTarget(slides, target, 'auto');\n    slides.style.setProperty('scroll-behavior', '');\n    return target;\n}\n\nfunction getAligned(slides, elements) {\n    const { leftPadding, rightPadding, centrePadding } = getPaddedBox(slides);\n\n    let n = elements.length;\n    let slide;\n\n    while ((slide = elements[--n])) {\n        const slideRect = rect(slide);\n\n        if (!slideRect) { continue; }\n\n        // Todo: do we need webkit property here?\n        const snap = getSnapX(slide);\n\n        // Imagine a detection line half a slides' width to the right of\n        // the left, the centre, or the right...\n        const detection = (slideRect.width / 2) + (\n            snap === 'left' ? leftPadding :\n            snap === 'right' ? rightPadding :\n            centrePadding\n        );\n\n        // ...and a slide registration position at it's corresponding left,\n        // centre or right position. Safari reports 2 values for\n        // scroll-snap-align it's the second that is the inline axis value\n        const x = snap === 'left' ? slideRect.left :\n            snap === 'right' ? slideRect.right :\n            slideRect.left + slideRect.width / 2 ;\n\n        // If position has crossed the detection going left, we're in the money\n        if (x <= detection) {\n            break;\n        }\n    }\n\n    // Return active slide\n    return slide;\n}\n\nfunction isGhost(slide) {\n    return !!slide.dataset.slideIndex;\n}\n\nexport function getActive(data) {\n    const { slides, elements, children } = data;\n    const aligned = getAligned(slides, elements);\n    return isGhost(aligned) ?\n        children[aligned.dataset.slideIndex] :\n        aligned ;\n}\n\nexport function updateActive(data) {\n    const { slides, children, elements } = data;\n    const current = getAligned(slides, elements);\n    let active;\n\n    // If current is a loop ghost jump to the actual slide it references\n    if (!current) { return; }\n    if (isGhost(current)) {\n        active = children[current.dataset.slideIndex];\n        jumpTo(slides, active);\n    }\n    else {\n        active = current;\n    }\n\n    data.activations.push(active);\n}\n\n\nexport function activateIndex(host, elements, i) {\n    const target = elements[i];\n    if (!target) { return; }\n    host.active = target;\n}\n\nexport function activateNext(host, elements, active) {\n    const i = elements.indexOf(active) + 1;\n    activateIndex(host, elements, i);\n}\n\nexport function activatePrevious(host, elements, active) {\n    const i = elements.indexOf(active) - 1;\n    activateIndex(host, elements, i);\n}\n", "\nimport events   from 'dom/events.js';\nimport overload from 'fn/overload.js';\n\nimport { getActive }         from './active.js';\nimport { getScrollInterval } from './consts.js';\n\nfunction resetScroll(slides, scrolls) {\n    slides.style.setProperty('scroll-snap-type', '');\n    scrolls.stop();\n}\n\nexport const processPointers = overload((data, e) => e.type, {\n    pointerdown: function(data, e) {\n        // First event is touchstart or mousedown\n        data.e0 = e;\n        data.x0 = e.clientX;\n        data.y0 = e.clientY;\n\n        return data;\n    },\n\n    pointermove: function(data, e) {\n        const x1 = e.clientX;\n        const y1 = e.clientY;\n\n        // Determine whether to start a gesture\n        if (!data.gesturing) {\n            // If the movement is more vertical than horizontal, don't count it\n            // as a swipe. Stop the stream and get out of here.\n            if (Math.abs(x1 - data.x0) < Math.abs(y1 - data.y0)) {\n                data.pointers.stop();\n                data.pointers = undefined;\n                data.e0 = undefined;\n                data.x0 = undefined;\n                data.y0 = undefined;\n                return;\n            }\n\n            data.scrollLeft0 = data.slides.scrollLeft;\n            data.slides.style.setProperty('scroll-snap-type', 'none', 'important');\n            data.slides.style.setProperty('scroll-behavior', 'auto', 'important');\n            data.gesturing = true;\n        }\n\n        const dx = e.clientX - data.x0;\n        data.slides.scrollLeft = data.scrollLeft0 - dx;\n\n        return data;\n    },\n\n    // Catches pointerup and pointercancel\n    default: function(data, e) {\n        const slides = data.slides;\n\n        // Track the end of click to allow click suppression\n        data.clickSuppressTime = e.timeStamp;\n\n        // Here we must go through a whole rigmarole in an attempt to avoid\n        // scroll jumps at the end of a swipe. Find out where it is, ...\n        const scrollLeft1 = slides.scrollLeft;\n        slides.style.setProperty('scroll-snap-type', '');\n\n        // and where it would snap to.\n        const scrollLeft2 = slides.scrollLeft;\n\n        // If those numbers are the same we are probably in FF, where removing\n        // scroll-snap does not cause an immediate jump to a snap alignment.\n        if (scrollLeft1 === scrollLeft2) {\n            // We can trust the browser to smooth scroll when we reset it.\n            slides.style.setProperty('scroll-behavior', '');\n        }\n        else {\n            // Otherwise we have to do things the hard way. We may as well\n            // preemptively update the active slide now, since we are sitting\n            // in the new position. This is not a crucial step, just makes the\n            // UI react a bit more quickly.\n            const active = getActive(data);\n            data.activations.push(active);\n\n            // Switch scroll-snap off again and put scroll back to position 1...\n            slides.style.setProperty('scroll-snap-type', 'none', 'important');\n            slides.scrollLeft = scrollLeft1;\n\n            // then manually smooth scroll over to position 2...\n            slides.style.setProperty('scroll-behavior', '');\n            slides.scrollTo({\n                top:  slides.scrollTop,\n                left: scrollLeft2,\n                behavior: 'smooth'\n            });\n\n            // and finally, switch scroll snapping back on when that scroll\n            // comes to rest (scrollInterval passes without an event).\n            events({ type: 'scroll', passive: true }, slides)\n            .reduce((frame, e, i, stream) => {\n                clearTimeout(frame);\n                return setTimeout(resetScroll, getScrollInterval() * 1000, slides, stream);\n            });\n\n            // Ooof. What a polava.\n        }\n\n        data.gesturing = false;\n        data.e0 = undefined;\n        data.x0 = undefined;\n        data.y0 = undefined;\n        data.pointers  = undefined;\n        data.scrollLeft0 = undefined;\n\n        return data;\n    }\n});\n", "\n// Much of this code has been purloined from targetable.js â€“ do we need the\n// hashchange tracking here? I have commented it\n\nimport Stream, { stop } from 'fn/stream/stream.js';\nimport { getScrollInterval, updateScrollInterval } from './consts.js';\n\nconst assign = Object.assign;\n\n// Capture scroll events in capture phase, as scroll events from elements\n// other than document do not bubble.\nconst captureOptions = {\n    capture: true,\n    passive: true\n};\n\nfunction fire(producer, e) {\n    producer.timer = undefined;\n    producer.stream.push(e);\n\n    const times = producer.times;\n    if (times.length > 1) { updateScrollInterval(times); }\n    times.length = 0;\n}\n\nfunction ScrollendsProducer(element) {\n    this.element = element;\n    this.times   = [];\n}\n\nassign(ScrollendsProducer.prototype, {\n    pipe: function(stream) {\n        this.stream = stream;\n        this.element.addEventListener('scroll', this, captureOptions);\n    },\n\n    handleEvent: function(e) {\n        const time = e.timeStamp / 1000;\n        this.times.push(time);\n\n        if (this.timer) {\n            clearTimeout(this.timer);\n        }\n\n        this.timer = setTimeout(fire, getScrollInterval() * 1000, this, e);\n    },\n\n    stop: function() {\n        this.element.removeEventListener('scroll', this);\n        stop(this.stream);\n    }\n});\n\nexport default function scrollends(element) {\n    return new Stream(new ScrollendsProducer(element));\n}\n", "\nimport equals          from 'fn/equals.js';\nimport get             from 'fn/get.js';\nimport noop            from 'fn/noop.js';\nimport nothing         from 'fn/nothing.js';\nimport overload        from 'fn/overload.js';\nimport Stream          from 'fn/stream.js';\nimport create          from 'dom/create.js';\nimport events          from 'dom/events.js';\nimport gestures        from 'dom/gestures.js';\nimport isPrimaryButton from 'dom/is-primary-button.js';\nimport { px }          from 'dom/parse-length.js';\nimport rect            from 'dom/rect.js';\nimport { trigger }     from 'dom/trigger.js';\n\nimport { $data }     from './consts.js';\nimport { scrollTo, jumpTo, updateActive } from './active.js';\nimport { processPointers } from './swipes.js';\nimport scrollends    from './scrollends.js';\n\n\nfunction getWidth(slides, slot, children) {\n    let n = children.length;\n    let r = -Infinity;\n\n    while (n--) {\n        const box   = rect(children[n]);\n        const right = box.x + box.width;\n        r = right > r ? right : r;\n    }\n\n    const box   = rect(slot);\n    const style = getComputedStyle(slides);\n    const pl    = px(style.paddingLeft || 0);\n    const pr    = px(style.paddingRight || 0);\n\n    return pl + pr + r - box.x;\n}\n\nfunction updateWidth(slides, slot, children) {\n    const width = getWidth(slides, slot, children);\n    slides.style.setProperty('--scroll-width', width + 'px');\n}\n\nfunction isSlide(slide) {\n    // Filter out loop ghosts\n    return !slide.dataset.slideIndex;\n}\n\n\n/* Lifecycle */\n\n/**\n'slide-active'\nEmitted by a slide when it is brought into scroll-snap alignment.\n**/\n\nexport default {\n    // Uhoh Kavea needs access to scroll events ... what we gonna do here?\n    mode: 'open',\n\n    construct: function(shadow) {\n        // Shadow DOM\n        const slot     = create('slot');\n        const slides   = create('div',  { part: 'slides', children: [slot] });\n        const controls = create('nav',  { part: 'controls', children: [\n            create('slot', { name: 'controls' })\n        ] });\n\n        // Add slots to shadow\n        shadow.append(slides, controls);\n\n        // Stream to push load to\n        const connects = Stream.broadcast();\n        const load     = Stream.broadcast();\n\n        // In Chrome and FF initial `slotchange` event is always sent before\n        // load, but not so in Safari where either order may happen (at a guess\n        // due to some caching strategy). Here we sanitise order by making\n        // slotchanges stream always fire after load.\n        const slotchanges = Stream\n            .combine({\n                host: load,\n                elements: events('slotchange', slot)\n                    .map((e) => data.elements = slot.assignedElements()),\n            })\n            .broadcast({ memory: true });\n\n        const mutations = slotchanges\n            .map((state) => {\n                const children = state.elements.filter(isSlide);\n                return equals(data.children, children) ?\n                    undefined :\n                    (data.children = children) ;\n            })\n            .broadcast({ memory: true, hot: true });\n\n        // Buffer stream for pushing children to scroll into view then activate\n        const views = Stream.of();\n\n        // Buffer stream for pushing children to activate\n        const activations = Stream.of();\n\n        // Broadcast stream for listening to changes to active\n        const actives = activations\n            .map((child) => (child.dataset.slideIndex ?\n                data.children[child.dataset.slideIndex] :\n                child\n            ))\n            .filter((child) => (data.active !== child && trigger('slide-active', child)))\n            .map((child) => data.active = child)\n            .broadcast({ memory: true, hot: true });\n\n        const clicks = events('click', shadow)\n            .filter(isPrimaryButton)\n            .broadcast();\n\n        // Track when scroll comes to rest...\n        const scrolls = scrollends(slides)\n            // ...but not after disconnect or mid finger gesture...\n            .filter((e) => (data.connected && !data.gesturing))\n            .broadcast();\n\n        // Private data\n        const data = this[$data] = {\n            clickSuppressTime: -Infinity,\n            connected: false,\n            host:      this,\n            style:     window.getComputedStyle(this),\n            elements:  nothing,\n            children:  nothing,\n            device:    undefined,\n            shadow,\n            slides,\n            slot,\n            controls,\n            connects,\n            load,\n            views,\n            activations,\n            actives,\n            slotchanges,\n            mutations,\n            clicks,\n            scrolls\n        };\n\n        // Create a stream of width updates on slotchanges and resizes. We\n        // cannot know if the slide-show is visible â€“ it may have display: none â€“\n        // so we must protect against update in cases where it is not, and cross\n        // our fingers it is updated somehow when it is made visible.\n        Stream\n        .merge(slotchanges, events('resize', window))\n        .filter((e) => (slot.offsetWidth && slot.offsetHeight))\n        .each((e) => updateWidth(slides, slot, data.elements));\n\n        // Wait for first slotchange/load, then maintain active position. In\n        // Chrome this fails on connect, as it appears the style is not applied\n        // immediately, so jumpTo() can't measure positions properly.\n        Stream\n        .combine({ slotchanges, connects })\n        .map((state) => (data.elements.includes(data.active) ?\n            data.active :\n            data.children[0]\n        ))\n        .map((child) => (data.connected ?\n            jumpTo(slides, child) :\n            child\n        ))\n        .pipe(activations);\n\n        // On change of .active view, check it is a child element that is not\n        // already active and scroll to it\n        Stream\n        .combine({ host: load, child: views })\n        .map((state) => (data.elements.includes(state.child) && data.active !== state.child ?\n            state.child :\n            undefined\n        ))\n        .map((child) => (data.connected ?\n            data.active ?\n                // This is an activation, scroll to the new active child\n                scrollTo(slides, child) :\n                // If active is not yet defined jump to the newly active child\n                jumpTo(slides, child) :\n            // If not connected pass the child through\n            child\n        ))\n        .pipe(activations);\n\n        // Keep active up-to-date following a scroll\n        scrolls.each((e) => updateActive(data));\n\n        // Enable single finger scroll on mouse devices. Dodgy idea in my\n        // opinion, but it does add support for mouse-only devices.\n        gestures({ threshold: '0.25rem', device: 'mouse' }, shadow)\n        .filter(() => data.children.length > 1)\n        .each((pointers) => {\n            // Keep a reference to pointers, it's used inside processPointers\n            data.pointers = pointers;\n            pointers.reduce(processPointers, data);\n        });\n\n        // Prevent default on immediate clicks after a gesture, and don't let\n        // them out: this is a gesture not a click.\n        clicks\n        .each((e) => {\n            if (e.timeStamp - data.clickSuppressTime < 120) {\n                e.preventDefault();\n                e.stopPropagation();\n            }\n        });\n\n        // Update positions on entry or exit from fullscreen.\n        events('fullscreenchange', window)\n        .filter((e) => data.active && slot.offsetWidth && slot.offsetHeight)\n        .each((e) => {\n            // If this slide-show was involved in the fullscreen change\n            // reposition the active slide, it may have been shuftied.\n            if (e.target === this || e.target.contains(this)) {\n                jumpTo(slides, data.active);\n            }\n        });\n\n        // Chrome behaves nicely when shifting focus between slot, Safari and\n        // FF not so much. Let's give them a helping hand at displaying the\n        // focused slide. Start by tracking the latest input device...\n        Stream\n        .merge(events('pointerdown', this), events('keydown', this))\n        .each((e) => (data.device = e.type === 'keydown' ?\n            'keyboard' :\n            e.pointerType\n        ));\n\n        // Then listen to focus events. Todo: FF not getting this.\n        events('focusin', this)\n        .filter((e) => (data.device === 'keyboard'))\n        .map((e) => (\n            // Is e.target a slide\n            data.children.indexOf(e.target) !== -1 ? e.target :\n            // Or inside a slide\n            data.children.find((child) => child.contains(e.target))\n        ))\n        .pipe(views);\n\n        // While the slide-show is focused allow left and right arrows to\n        // navigate.\n        events('keydown', this)\n        .filter(() => document.activeElement === this || this.contains(document.activeElement))\n        .map(overload(get('keyCode'), {\n            // Left arrow\n            37: (e) => {\n                // If we don't preventDefault FF jumps two slot - it scrolls\n                // once for the handler and once for its default scroll paging\n                e.preventDefault();\n                return data.elements[data.elements.indexOf(data.active) - 1];\n            },\n            // Right arrow\n            39: (e) => {\n                // If we don't preventDefault FF jumps two slot - it scrolls\n                // once for the handler and once for its default scroll paging\n                e.preventDefault();\n                return data.elements[data.elements.indexOf(data.active) + 1];\n            },\n            // Other keys\n            default: noop\n        }))\n        .pipe(views);\n\n        // Neuter streams intended as push-only, just as a sanity check\n        if (window.DEBUG) {\n            load.pipe = null;\n        }\n    },\n\n    load: function (shadow) {\n        const data = this[$data];\n        data.load.push(this);\n    },\n\n    connect: function(shadow) {\n        const data = this[$data];\n        data.connected = true;\n        data.connects.push(true);\n    },\n\n    disconnect: function(shadow) {\n        const data = this[$data];\n        data.connected = false;\n        //data.connects.push(false);\n    }\n};\n", "\n/**\ncreateBoolean(definition)\nCreates a boolean attribute/property definition for element(), where\n`definition` is an object with the functions:\n\n```js\n{\n    enable: fn,\n    disable: fn,\n    getState: fn\n}\n```\n**/\n\nexport default function createBoolean(definition) {\n    function update(element, state) {\n        if (definition.getState(element) === state) { return; }\n        return definition[state ? 'enable' : 'disable'](element);\n    }\n\n    return {\n        attribute: function(value) {\n            return update(this, value !== null);\n        },\n\n        set: function(value) {\n            return update(this, !!value);\n        },\n\n        get: function() {\n            return definition.getState(this);\n        },\n\n        enumerable: true\n    };\n}\n", "/**\nremove(array, value)\nRemove `value` from `array`. Where `value` is not in `array`, does nothing.\n**/\n\nimport curry from './curry.js';\n\nexport function remove(array, value) {\n    if (array.remove) { array.remove(value); }\n\n    let i;\n    while ((i = array.indexOf(value)) !== -1) {\n        array.splice(i, 1);\n    }\n\n    return array;\n}\n\nexport default curry(remove, true);\n", "\nimport { remove } from 'fn/remove.js';\n\nconst assign = Object.assign;\n\n\n/*\nTokenList(element, definitions)\n\nCreate a TokenList-like object.\n\nThe optional `definitions` object is a map of accepted tokens, each one\nrepresented by an object with the functions `enable()` and `disable()`:\n\n```js\nnew TokenList(element, {\n    token: {\n        enable: function(element) { ... },\n        disable: function(element) { ... }\n    }\n});\n```\n*/\n\nexport default function TokenList(element, definitions) {\n    this.element     = element;\n    this.definitions = definitions;\n    this.tokens      = [];\n}\n\nassign(TokenList.prototype, {\n    contains: function(string) {\n\t\treturn this.tokens.includes(string);\n\t},\n\n    add: function() {\n        let n = arguments.length;\n\n        while (n--) {\n            const token = arguments[n];\n\n            if (!this.tokens.includes(token)) {\n                this.tokens.push(token);\n\n                // Call definition.enable() with element as context\n                if (this.supports(token)) {\n                    this.definitions[token].enable(this.element);\n                }\n            }\n        }\n    },\n\n    remove: function() {\n        let n = arguments.length;\n\n        while (n--) {\n            const token = arguments[n];\n\n            if (this.tokens.includes(token)) {\n                remove(this.tokens, token);\n\n                // Call the definition.disable() with element as context\n                if (this.supports(token)) {\n                    this.definitions[token].disable(this.element);\n                }\n            }\n        }\n    },\n\n    supports: function(token) {\n        return !!this.definitions && !!this.definitions[token];\n    }\n});\n", "\nconst A      = Array.prototype;\n\n/*\nupdate(list, tokens)\nThe missing update function for TokenLists. Compares existing tokens with\na new list of tokens, removes those that are not in the new list, and adds\nthose that do not exist.\n*/\n\nexport default function updateTokenList(list, tokens) {\n    const removes = list.tokens.slice();\n    const adds    = A.slice.apply(tokens);\n\n    let n = removes.length;\n    while (n--) {\n        if (adds.includes(removes[n])) {\n            removes.splice(n, 1);\n        }\n    }\n\n    list.remove.apply(list, removes);\n    list.add.apply(list, adds);\n}\n", "\nimport TokenList       from './token-list.js';\nimport updateTokenList from './update-token-list.js';\n\n\n/**\ncreateTokenList(definitions)\nCreates a token list attribute/property definition ready for element(), where\n`definitions` is an object of named token definitions of the form:\n\n```js\ncreateTokenList({\n    token: {\n        enable: fn,\n        disable: fn\n    },\n\n    ...\n})\n```\n**/\n\nexport default function createTokenList(definitions) {\n    // We lazily create a TokenList as needed, not so much for efficacy, but\n    // because we don't have a reference to element until the attribute or\n    // property is accessed. We have to store that TokenList somewhere unique -\n    // this definition may be shared across many elements - so lets make a\n    // symbol property that identifies this definition. I know. It's a little\n    // bit meh, but this is a problem with the custom elements API, really.\n    const $tokenlist = Symbol('TokenList');\n\n    function update(element, string) {\n        const list = element[$tokenlist] || (element[$tokenlist] = new TokenList(element, definitions));\n        updateTokenList(list, string.trim().split(/\\s+/));\n    }\n\n    return {\n        attribute: function(value) {\n            update(this, value || '');\n        },\n\n        set: function(value) {\n            update(this, value + '');\n        },\n\n        get: function() {\n            return this[$tokenlist] || (this[$tokenlist] = new TokenList(this, definitions));\n        },\n\n        enumerable: true\n    };\n}\n", "\n/*\nAutoplay\n*/\n\nimport id         from 'fn/id.js';\nimport get        from 'fn/get.js';\nimport overload   from 'fn/overload.js';\nimport parseValue from 'fn/parse-value.js';\nimport Stream     from 'fn/stream.js';\nimport events     from 'dom/events.js';\n\nimport { $data }  from './consts.js';\n\nconst parseTime = parseValue({\n    's':  id,\n    'ms': (n) => n / 1000\n});\n\n/*\nTODO: dont autoplay when hidden??\n\nevents('visibilitychange', document).each((e) => {\n    if (document.hidden) {\n\n    }\n    else {\n\n    }\n});\n*/\n\nfunction change(data) {\n    const { active, children, elements, host } = data;\n    const i = elements.indexOf(active);\n    const target = elements[i + 1] || children[0];\n    //console.log('AUTOPLAY CHANGE', target);\n    data.autoplay.timer = null;\n    if (!target) { return; }\n    host.active = target;\n}\n\nfunction update(data) {\n    const { active, style } = data;\n    const duration = parseTime(\n        window\n        .getComputedStyle(active)\n        .getPropertyValue('--slide-duration') ||\n        style.getPropertyValue('--slide-duration')\n    );\n\n    clearTimeout(data.autoplay.timer);\n    //console.log('AUTOPLAY UPDATE', duration);\n    data.autoplay.timer = setTimeout(change, duration * 1000, data);\n}\n\nfunction cancel(data) {\n    //console.log('AUTOPLAY CANCEL');\n    clearTimeout(data.autoplay.timer);\n    data.autoplay.timer = null;\n}\n\nexport function enable(host) {\n    const data = host[$data];\n    const { actives } = data;\n\n    // Add an object to store autoplay state\n    const autoplay = data.autoplay = {};\n\n    // Create a stream of hover states starting with false. Note that this is\n    // an assumption - the cursor may well be in hover state when autoplay is\n    // enabled.\n    const hovers = Stream.merge(\n        [false],\n        events('pointerenter pointerleave', host)\n        .map((e) => e.type === 'pointerenter')\n    );\n\n    // Create a stream of focus inside state\n    const focuses = Stream.merge(\n        [host.contains(document.activeElement)],\n        events('focusin focusout', host)\n        .map(overload(get('type'), {\n            'focusin': (e) => true,\n            'focusout': (e) => host.contains(e.relatedTarget)\n        }))\n    )\n    // Deduplicate\n    .map(((v) => (value) => (v === value ? undefined : (v = value)))());\n\n    // Schedule a change timer on every activate where the user is not\n    // hovering, or at the end of the hover\n    autoplay.updates = Stream\n        .combine({ active: actives, hover: hovers, focus: focuses })\n        .each((state) => (state.hover || state.focus ?\n            cancel(data) :\n            update(data)\n        ));\n}\n\nexport function disable(host) {\n    const data = host[$data];\n    cancel(data);\n    data.autoplay.updates.stop();\n    data.autoplay = undefined;\n}\n\nexport function getState(host) {\n    const data = host[$data];\n    return !!data.autoplay;\n}\n", "\nimport rect   from 'dom/rect.js';\n\nimport { $data }  from './consts.js';\nimport { jumpTo } from './active.js';\n\n\nfunction toLoopGhost(slide, i) {\n    const ghost = slide.cloneNode(true);\n    ghost.dataset.slideIndex = i;\n    ghost.removeAttribute('id');\n    ghost.setAttribute('aria-hidden', 'true');\n    ghost.tabIndex = '-1';\n    return ghost;\n}\n\nfunction render(data) {\n    const { active, children, host, slides } = data;\n\n    if (data.loop.prepends) {\n        data.loop.prepends.forEach((slide) => slide.remove());\n        data.loop.appends.forEach((slide) => slide.remove());\n        data.loop.prepends = undefined;\n        data.loop.appends = undefined;\n    }\n\n    if (children.length < 2) {\n        // Dont wait for the slotchange event, which is fired after the one\n        // that caused this render has completed. Synchronously update\n        // data.elements or our state is out of sync for the activation of\n        // other components.\n        data.elements = data.slot.assignedElements();\n        return;\n    }\n\n    // Expand children to the left and right by at least 1 slide plus the width\n    // of the host slide-show. Todo: by rights, this should change on resize.\n    const loopOverflow = host.clientWidth;\n    const boxes        = children.map(rect);\n    const left         = boxes[1].left;\n    const right        = boxes[boxes.length - 2].right;\n\n    // Always append a minimum of 1 slide\n    let n = 1;\n    while (boxes[++n] && boxes[n].left < left + loopOverflow);\n    const appends = children.slice(0, n).map(toLoopGhost);\n\n    // Always prepend a minimum of 1 slide\n    n = boxes.length - 2;\n    while (boxes[--n] && boxes[n].right > right - loopOverflow);\n    const prepends = children.slice(++n).map((slide, i) => toLoopGhost(slide, n + i));\n\n    host.prepend.apply(host, prepends);\n    host.append.apply(host, appends);\n    data.loop.prepends = prepends;\n    data.loop.appends  = appends;\n\n    // Dont wait for the slotchange event, which is fired after the one\n    // that caused this render has completed. Synchronously update\n    // data.elements or our state is out of sync for the activation of\n    // other components.\n    data.elements = data.slot.assignedElements();\n\n    jumpTo(slides, active || children[0]);\n}\n\nexport function enable(host) {\n    const data = host[$data];\n    const { mutations } = data;\n\n    // Add an object to store loop state\n    const loop = data.loop = {};\n\n    // Render ghosts when children change\n    loop.renders = mutations.each((children) => render(data));\n}\n\nexport function disable(host) {\n    const data = host[$data];\n    if (data.loop) {\n        data.loop.prepends && data.loop.prepends.forEach((slide) => slide.remove());\n        data.loop.appends  && data.loop.appends.forEach((slide) => slide.remove());\n        data.loop.renders.stop();\n        data.loop = undefined;\n    }\n}\n\nexport function getState(host) {\n    const data = host[$data];\n    return !!data.loop;\n}\n", "\n/**\nslot=\"prev-button\"\n\nAvailable when the slideshow has `controls=\"navigation\"` enabled, this slot\nallows the inclusion of html content into the 'previous' navigation button. By\ndefault the slot contains an inline SVG of an icon, and some text (in English).\nDefining HTML for the slot replaces that default content:\n\n```html\n<slide-show controls=\"navigation\">\n    <svg slot=\"prev-button\" aria-hidden=\"true\">\n        <use href=\"#back-icon\" />\n    </svg>\n    <span slot=\"prev-button\">DerniÃ¨re</span>\n</slide-show>\n```\n**/\n\n/**\nslot=\"next-button\"\nAvailable when the slideshow has `controls=\"navigation\"` enabled, this slot\nallows the inclusion of html content into the 'next' navigation button. By\ndefault the slot contains an inline SVG of an icon, and some text (in English).\nDefining HTML for the slot replaces that default content:\n\n```html\n<slide-show controls=\"navigation\">\n    <svg slot=\"next-button\" aria-hidden=\"true\">\n        <use href=\"#forward-icon\" />\n    </svg>\n    <span slot=\"next-button\">Prochaine</span>\n</slide-show>\n```\n**/\n\nimport Stream   from 'fn/stream.js';\nimport create   from 'dom/create.js';\nimport delegate from 'dom/delegate.js';\n\nimport { activatePrevious, activateNext, activateIndex } from './active.js';\nimport { $data }         from './consts.js';\n\nfunction update(slides, prev, next, elements, i) {\n    // Preemptively hide buttons now (before new active is detected at\n    // end of scroll)\n    if (i === 0 || slides.scrollLeft === 0) {\n        prev.hidden = true;\n    }\n    else {\n        prev.hidden = false;\n    }\n\n    if (i === elements.length - 1 || slides.scrollLeft >= slides.scrollWidth - slides.clientWidth) {\n        next.hidden = true;\n    }\n    else {\n        next.hidden = false;\n    }\n}\n\nexport function enable(host) {\n    const data = host[$data];\n    const { actives, clicks, slotchanges, slides, scrolls } = data;\n\n    // Add an object to store navigation state\n    const navigation = data.navigation = {\n        prev: create('button', {\n            part: 'prev-button',\n            type: \"button\",\n            name: \"navigation\",\n            value: \"-1\",\n            children: [create('slot', {\n                name: 'prev-button',\n                html: `\n                    <svg viewBox=\"0 0 30 40\" aria-hidden=\"true\">\n                        <path d=\"M19,9 L9,20 L19,31\"></path>\n                    </svg>\n                    Previous\n                `\n            })]\n        }),\n\n        next: create('button', {\n            part: 'next-button',\n            type: \"button\",\n            name: \"navigation\",\n            value: \"1\",\n            children: [create('slot', {\n                name: 'next-button',\n                html: `\n                    <svg viewBox=\"0 0 30 40\" aria-hidden=\"true\">\n                        <path d=\"M11,9 L21,20 L11,31\"></path>\n                    </svg>\n                    Next\n                `\n            })]\n        })\n    };\n\n    data.controls.prepend(navigation.prev, navigation.next);\n\n    // Create a stream of updates starting with the current active\n    navigation.updates = Stream\n    .combine({ active: actives, changes: slotchanges, scroll: scrolls })\n    .each((state) => update(\n        slides,\n        navigation.prev,\n        navigation.next,\n        state.changes.elements,\n        state.changes.elements.indexOf(state.active)\n    ));\n\n    navigation.clicks = clicks.each(delegate({\n        // Slotted content does not delegate through it's parent element, but it\n        // does delegate through shadow, weirdly\n        '[slot=\"prev-button\"]': (node, e) => {\n            activatePrevious(host, data.elements, data.active);\n        },\n\n        '[slot=\"next-button\"]': (node, e) => {\n            activateNext(host, data.elements, data.active);\n        },\n\n        '[name=\"navigation\"]': (button, e) => {\n            const i = data.elements.indexOf(data.active) + parseFloat(button.value);\n            activateIndex(host, data.elements, i);\n        }\n    }));\n}\n\nexport function disable(host) {\n    const data = host[$data];\n    data.navigation.prev.remove();\n    data.navigation.next.remove();\n    data.navigation.updates.stop();\n    data.navigation.clicks.stop();\n    data.navigation = undefined;\n}\n\nexport function getState(host) {\n    const data = host[$data];\n    return !!data.navigation;\n}\n", "\n/**\ndelegate(map)\n\nTakes an object map of functions keyed to selectors, and returns a function that\nhandles event objects, delegating them to the first function whose selector\nmatches the event target. Functions are passed the target node and the event\nobject, plus any other arguments passed to the handler.\n\n```\ndelegate({\n\t'button': (button, event) => {}\n})\n```\n**/\n\nexport default function delegate(object) {\n\tif (typeof object !== 'object' || arguments.length > 1) {\n\t\tthrow new Error('delegate() now takes an object of selector:fn pairs.');\n\t}\n\n\t// Create an event handler that looks up the ancestor tree\n\t// to find selector.\n\treturn function handle(e) {\n\t\tconst target = e.target;\n\t\tlet selector;\n\t\tfor (selector in object) {\n\t\t\tconst node = target.closest(selector);\n\t\t\tif (node) {\n\t\t\t\treturn object[selector](node, ...arguments);\n\t\t\t}\n\t\t}\n\t};\n}\n", "\nimport Stream   from 'fn/stream.js';\nimport create   from 'dom/create.js';\nimport delegate from 'dom/delegate.js';\n\nimport { $data }          from './consts.js';\n\n\nfunction update(pagination, children, target) {\n    const { active, buttons, index } = pagination;\n\n    // Do nothing where target is already the active page-button\n    if (active === target) { return; }\n\n    if (index > -1) {\n        pagination.activeSpan.remove();\n        buttons.children[index].part.remove('page-button-active');\n    }\n\n    const i = children.indexOf(target);\n    if (i === -1) { return; }\n\n    buttons.children[i].part.add('page-button-active');\n    buttons.children[i].append(pagination.activeSpan);\n    pagination.index  = i;\n    pagination.active = target;\n}\n\nfunction render(controls, pagination, shadow, children) {\n    if (pagination.buttons) {\n        pagination.buttons.remove();\n        pagination.buttons = undefined;\n    }\n\n    // Don't generate pagination when there are 0 or 1 slides\n    if (children.length < 2) { return children.length; }\n\n    pagination.buttons = create('div', {\n        part: 'pagination',\n        children: children.map((slide, i) => create('button', {\n            part: 'page-button',\n            type: 'button',\n            name: 'pagination',\n            value: i\n        }))\n    });\n\n    controls.append(pagination.buttons);\n    return children.length;\n}\n\nexport function enable(host) {\n    const data = host[$data];\n    const { shadow, actives, clicks, mutations } = data;\n\n    // Add an object to store autoplay state\n    const pagination = data.pagination = {\n        // Element containing accessibility text marking a button as active\n        activeSpan: create('span', { class: 'invisible', text: '(Current slide)' })\n    };\n\n    // Render buttons when children change\n    pagination.mutations = mutations\n    .each(() => render(data.controls, pagination, shadow, data.children));\n\n    // Create a new stream of updates that happen when a slide activates and\n    // when enough children become available for pagination\n    pagination.updates = Stream\n    .combine({ active: actives, children: mutations })\n    .filter((state) => state.children.length > 1)\n    .each((state) => update(pagination, data.children, data.active));\n\n    pagination.clicks = clicks.each(delegate({\n        '[name=\"pagination\"]': function(button, e) {\n            const { host } = data;\n            const children = data.children;\n            const target = children[button.value];\n\n            if (!target) { return; }\n            host.active = target;\n\n            // Preemptively highlight pagination button\n            update(pagination, children, target);\n        }\n    }));\n}\n\nexport function disable(host) {\n    const data = host[$data];\n    data.pagination.buttons.remove();\n    data.pagination.mutations.stop();\n    data.pagination.updates.stop();\n    data.pagination.clicks.stop();\n    data.pagination = undefined;\n}\n\nexport function getState(host) {\n    const data = host[$data];\n    return !!data.pagination;\n}\n", "\n/**\nslot=\"fullscreen-button\"\n\nAvailable when the slideshow has `controls=\"fullscreen\"` enabled, this slot\nallows the inclusion of html content into the fullscreen button. By default the\nslot contains an inline SVG of an icon, and some text (in English). Defining\nHTML for the slot replaces that default content:\n\n```html\n<slide-show controls=\"fullscreen\">\n    <svg slot=\"fullscreen-button\" aria-hidden=\"true\">\n        <use href=\"#fullscreen-icon\" />\n    </svg>\n    <span slot=\"fullscreen-button\">Plein Ã©cran</span>\n</slide-show>\n```\n**/\n\nimport create    from 'dom/create.js';\nimport delegate  from 'dom/delegate.js';\nimport events    from 'dom/events.js';\nimport { fullscreenEnabled, getFullscreenElement, enterFullscreen, exitFullscreen } from 'dom/fullscreen.js';\n\nimport { $data } from './consts.js';\n\nif (window.DEBUG && !fullscreenEnabled) {\n    console.warn('<slide-show> fullscreen API not supported, fullscreen controls will not be rendered');\n}\n\nexport function enable(host) {\n    const data = host[$data];\n\n    if (!fullscreenEnabled) {\n        return;\n    }\n\n    // Add an object to store navigation state\n    const fullscreen = data.fullscreen = {\n        button: create('button', {\n            part: 'fullscreen-button',\n            type: \"button\",\n            name: \"fullscreen\",\n            children: [create('slot', {\n                name: 'fullscreen-button',\n                html: `\n                    <svg viewBox=\"0 0 40 40\" aria-hidden=\"true\">\n                        <path class=\"fullscreen-hidden\" d=\"M9,9 L17,17 M9,15 L9,9 L15,9 M9,31 L17,23 M9,25 L9,31 L15,31 M31,31 L23,23 M25,31 L31,31 L31,25 M31,9 L23,17 M25,9 L31,9 L31,15\"></path>\n                        <path class=\"fullscreen-shown\"  d=\"M9,9 L31,31 M9,31 L31,9\"></path>\n                    </svg>\n                    <span class=\"fullscreen-hidden\">Open in fullscreen</span>\n                    <span class=\"fullscreen-shown\">Close fullscreen</span>\n                `\n            })]\n        }),\n    };\n\n    //data.fullscreen.button.append(text);\n    data.controls.append(fullscreen.button);\n\n    fullscreen.changes = events('fullscreenchange', host)\n    .filter((e) => getFullscreenElement() === host)\n    .each((e) => {\n        // Setup fullscreen\n\n        // In Chrome and FF, the fullscreen element receives focus without an\n        // explicit tabIndex, in Safari we must encourage it by adding one.\n        // When focus is inside a custom element document.activeElement points\n        // to the host (or is this true only for closed shadows?)\n        if (document.activeElement !== host) {\n            fullscreen.tabIndex = host.tabIndex;\n            if (host.tabIndex < 0) { host.tabIndex = 0; }\n            host.focus();\n        }\n\n        // Setup fullscreen exit\n        const fullscreenend = events('fullscreenchange', host)\n        .each((e) => {\n            host.tabIndex = fullscreen.tabIndex;\n            fullscreen.tabIndex = undefined;\n            fullscreenend.stop();\n        });\n    });\n\n    fullscreen.clicks = data.clicks.each(delegate({\n        // Slotted content does not delegate through it's parent element, but it\n        // does delegate through shadow, weirdly\n        '[slot=\"fullscreen-button\"], [name=\"fullscreen\"]': (target, e) => {\n            const fullscreenCurrent = getFullscreenElement();\n\n            // Make button act as toggle: close the fullscreen\n            if (fullscreenCurrent === host) {\n                exitFullscreen();\n                return;\n            }\n\n            if (fullscreenCurrent) {\n                exitFullscreen();\n            }\n\n            enterFullscreen(host);\n        }\n    }));\n}\n\nexport function disable(host) {\n    const data = host[$data];\n    const fullscreenCurrent = getFullscreenElement();\n\n    if (fullscreenCurrent === host) {\n        exitFullscreen();\n    }\n\n    data.fullscreen.button.remove();\n    data.fullscreen.clicks.stop();\n    data.fullscreen.changes.stop();\n    data.fullscreen = undefined;\n}\n\nexport function getState(host) {\n    const data = host[$data];\n    return !!data.fullscreen;\n}\n", "\n// Not true in iPhone iOS.\nexport const fullscreenEnabled = document.fullscreenEnabled\n    || document.mozFullscreenEnabled\n    || document.webkitFullscreenEnabled\n    || document.msFullscreenEnabled ;\n\nexport function getFullscreenElement() {\n    return document.fullscreenElement\n        || document.webkitFullscreenElement\n        || document.mozFullScreenElement\n        || document.msFullscreenElement ;\n}\n\nexport function enterFullscreen(node) {\n    return node.requestFullscreen ? node.requestFullscreen() :\n        node.webkitRequestFullscreen ? node.webkitRequestFullscreen() :\n        node.mozRequestFullScreen ? node.mozRequestFullScreen() :\n        node.msRequestFullscreen ? node.msRequestFullscreen() :\n        undefined ;\n}\n\nexport function exitFullscreen() {\n    document.exitFullscreen ? document.exitFullscreen() :\n    document.webkitExitFullscreen ? document.webkitExitFullscreen() :\n    document.mozCancelFullScreen ? document.mozCancelFullScreen() :\n    document.msExitFullscreen ? document.msExitFullscreen() :\n    undefined ;\n}\n", "\nimport createBoolean   from 'dom/element/create-boolean.js';\nimport createTokenList from 'dom/element/create-token-list.js';\n\nimport { $data }       from './consts.js';\nimport * as autoplay   from './autoplay.js';\nimport * as loop       from './loop.js';\nimport * as navigation from './navigation.js';\nimport * as pagination from './pagination.js';\nimport * as fullscreen from './fullscreen.js';\n\n\n/* Properties */\n\nexport default {\n    /**\n    active=\"#id\"\n    Sets the initial scroll-snapped slide, where `#id` must be the id of a\n    direct child of the `<slide-show>`.\n\n    ```html\n    <slide-show active=\"#tractor\">\n        <img src=\"./images/tractor.jpg\" draggable=\"false\" id=\"tractor\">\n    </slide-show>\n    ```\n    **/\n\n    /**\n    .active\n    Gets or sets the currently scroll-snapped slide.\n\n    ```js\n    const activeSlide = slideshow.active;\n    ```\n\n    May be set to one of the child elements, or to the id of one of the\n    child elements, which causes the `slide-show` to scroll.\n\n    ```js\n    slideshow.active = 'slide-1';\n    ```\n    **/\n\n    active: {\n        attribute: function(id) {\n            this.active = id;\n        },\n\n        set: function(id) {\n            const data = this[$data];\n\n            // Accept an id\n            const child = typeof id === 'object' ?\n                id :\n                /^\\d/.test(id + '') ?\n                    this.querySelector('#\\\\3' + (id + '')[0] + ' ' + (id + '').slice(1)) :\n                /^\\#/.test(id + '') ?\n                    this.querySelector(id) :\n                this.querySelector('#' + id) ;\n\n            data.views.push(child);\n        },\n\n        get: function() {\n            return this[$data].active;\n        }\n    },\n\n    /**\n    .activateNext()\n    Activates the next slide.\n    **/\n\n    activateNext: {\n        value: function() {\n            const { elements, views, active } = this[$data];\n            views.push(elements[elements.indexOf(active) + 1]);\n            return this;\n        }\n    },\n\n    /**\n    .activatePrevious()\n    Activates the previous slide.\n    **/\n\n    activatePrevious: {\n        value: function() {\n            const { elements, views, active } = this[$data];\n            views.push(elements[elements.indexOf(active) - 1]);\n            return this;\n        }\n    },\n\n    /**\n    autoplay=\"\"\n    Boolean attribute. When present the `slide-show` activates the next\n    slide after a pause.\n\n    ```html\n    <slide-show autoplay>â€¦</slide-show>\n    ```\n\n    The pause duration may be set with the CSS variable\n    `--slide-duration`. Autoplay is also paused when a mouse pointer is\n    inside the `slide-show`, or when a slide has focus.\n    **/\n\n    /**\n    .autoplay\n\n    Boolean property. When `true` the slide-show activates the next\n    slide after a pause. The pause duration may be set with the CSS variable\n    `--slide-duration`. Autoplay is also paused when a mouse pointer is\n    inside the `slide-show`, or when a slide has focus.\n\n    ```js\n    slideshow.autoplay = true;\n    ```\n    **/\n\n    autoplay: createBoolean(autoplay, 'autoplay'),\n\n    /**\n    controls=\"\"\n    An attribute that accepts the tokens `\"navigation\"`, `\"pagination\"`\n    and `\"fullscreen\"`. The presence of one of these tokens enables the\n    corresponding controls.\n\n    ```html\n    <slide-show controls=\"navigation fullscreen\">â€¦</slide-show>\n    ```\n    **/\n\n    /**\n    .controls\n    A TokenList object (like `.classList`) that supports the tokens\n    `\"navigation\"`, `\"pagination\"` and `\"fullscreen\"`.\n\n    ```js\n    slideshow.controls.add('pagination');\n    ```\n    **/\n\n    controls: createTokenList({\n        'navigation': navigation,\n        'pagination': pagination,\n        'fullscreen': fullscreen\n    }),\n\n    /**\n    loop=\"\"\n    Boolean attribute. When present, the `slide-show` behaves as a continuous\n    loop.\n\n    ```html\n    <slide-show loop>â€¦</slide-show>\n    ```\n\n    Looping works by duplicating some of the children of the `slide-show`.\n    Duplicate elements are given `aria-hidden=\"true\"` and `tab-index=\"-1\"`, and\n    have `id` attributes stripped off in an attempt to make them inert.\n    **/\n\n    /**\n    .loop\n    Boolean property. When `true`, the `slide-show` behaves as a continuous loop.\n\n    ```js\n    slideshow.loop = true;\n    ```\n\n    Looping works by duplicating some of the children of the `slide-show`.\n    Duplicate elements are given `aria-hidden=\"true\"` and `tab-index=\"-1\"`, and\n    have `id` attributes stripped off in an attempt to make them inert.\n    **/\n\n    loop: createBoolean(loop, 'loop')\n};\n", "\n/** Get started\n\nDownload the latest release:\n\n[`github.com/stephband/slide-show/releases`](https://github.com/stephband/slide-show/releases)\n\nThen include the JS and CSS files:\n\n```html\n<link rel=\"stylesheet\" href=\"./build/slide-show.css\" />\n<script type=\"module\" src=\"./build/slide-show.js\"></script>\n```\n\nYou can now use the `<slide-show>` in your HTML. The `<slide-show>` example\nabove looks something like this:\n\n```html\n<slide-show autoplay loop controls=\"navigation pagination fullscreen\">\n    <img src=\"./images/donkeys.jpg\" draggable=\"false\" />\n    <img src=\"./images/tractor.jpg\" draggable=\"false\" />\n    <img src=\"./images/mauverin.jpg\" draggable=\"false\" />\n</slide-show>\n```\n\nA `<slide-show>` lays out its children horizontally, by default in `grid` layout.\nContent is horizontally scrollable via touch or trackpad, draggable with a mouse\n(making it a Good Idea to add `draggable=\"false\"`to images and links), and also\nnavigable via keyboard focus.\n\nA `<slide-show>` is not just for images. Content may be any HTML. Here's a\n`<slide-show>` being employed as tabbed navigation:\n\n<slide-show class=\"tab-slide-show\">\n    <a class=\"tab-button button\" href=\"#1\" draggable=\"false\">Explore</a>\n    <a class=\"tab-button button active\" href=\"#2\" draggable=\"false\">Buy</a>\n    <a class=\"tab-button button\" href=\"#3\" draggable=\"false\">Free trial</a>\n    <a class=\"tab-button button\" href=\"#4\" draggable=\"false\">About</a>\n    <a class=\"tab-button button\" href=\"#5\" draggable=\"false\">Student discount</a>\n    <a class=\"tab-button button\" href=\"#6\" draggable=\"false\">Contact us</a>\n</slide-show>\n**/\n\n// Polyfill Element.scrollTo() for Safari\n// Not needed since Safari 14:\n// https://caniuse.com/?search=scrollto\n//import 'dom/polyfills/element.scrollto.js';\n\nimport element    from 'dom/element.js';\nimport lifecycle  from './modules/lifecycle.js';\nimport properties from './modules/properties.js';\n\nconst stylesheet = window.slideshowStylesheet || import.meta.url.replace(/\\/[^\\/]*\\.js/, '/shadow.css');\n\nexport default element('slide-show', lifecycle, properties, stylesheet, 'stephen.band/slide-show/');\n"],
  "mappings": "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",
  "names": ["cacheByObject", "fn", "map", "object", "value", "A", "applyFn", "fn", "args", "curry", "muteable", "arity", "memo", "cacheByObject", "object", "partial", "curry_default", "exec", "regex", "fn", "string", "data", "tokens", "output", "exec_default", "curry_default", "error", "regex", "reducers", "string", "reduce", "acc", "tokens", "n", "capture", "output", "exec", "capture_default", "curry_default", "id", "value", "overload", "fn", "map", "key", "handler", "noop", "assignProperty", "overload", "id", "noop", "name", "node", "object", "content", "setAttribute", "assign", "attributes", "names", "n", "assign_default", "curry_default", "svgNamespace", "template", "typeofContent", "type", "content", "createContextFragment", "context", "html", "range", "createSVG", "overload", "tag", "node", "object", "assign_default", "createHTML", "create", "id", "text", "fragment", "create_default", "onceEvent", "toLoadPromise", "element", "resolve", "reject", "to_prefetch_promise_default", "cacheByObject", "url", "link", "create_default", "promise", "toLoadPromise", "$internals", "attachInternals", "element", "internals", "create_default", "value", "createInternals", "Element", "shadow", "getInternals", "define", "nothing", "constructors", "formProperties", "name", "getInternals", "supportsCustomisedBuiltIn", "getElementConstructor", "tag", "constructors", "parseNameTag", "capture_default", "data", "captures", "name", "constructProperty", "element", "descriptor", "transferProperty", "key", "value", "createShadow", "elem", "options", "stylesheet", "shadow", "link", "create_default", "fillShadowFromTemplate", "template", "hasPropertyAttribute", "option", "hasPropertyDefinition", "groupAttributeProperty", "entry", "definition", "lifecycle", "api", "log", "constructor", "attributes", "properties", "nothing", "Element", "internals", "createInternals", "params", "links", "style", "toLoadPromise", "to_prefetch_promise_default", "define", "formProperties", "disabled", "getInternals", "old", "attribute", "equals", "a", "b", "akeys", "bkeys", "n", "i", "equals_default", "curry_default", "get", "key", "object", "get_default", "curry_default", "arg", "n", "self", "create", "freeze", "nothing_default", "noop", "self", "arg", "id", "evaluatingSignal", "setDependency", "signal", "dependent", "n", "invalidateDependents", "hasInput", "input", "Signal", "_Signal", "object", "value", "ValueSignal", "fn", "context", "ComputeSignal", "name", "PropertySignal", "initial", "ObserveSignal", "previous", "evaluatingSignal", "#value", "#fn", "#context", "#valid", "promise", "#signal", "#evaluate", "assign", "define", "isExtensible", "O", "$trap", "properties", "isMuteable", "object", "getSignal", "signals", "name", "Signal", "isMutableProperty", "descriptor", "prototype", "getValue", "DataTrap", "object", "properties", "$trap", "define", "assign", "name", "proxy", "value", "getValue", "Data", "length", "force", "isMuteable", "fn", "initial", "trap", "signal", "getSignal", "Signal", "isIterable", "object", "to_type_default", "object", "assign", "create", "$listeners", "call", "overload", "to_type_default", "fn", "object", "pipe", "stream", "output", "unpipe", "n", "stop", "listeners", "readable", "value", "Stream", "pipeable", "type", "Each", "options", "Broadcast", "Filter", "FlatMap", "Map", "accumulator", "Reduce", "initial", "Scan", "m", "Slice", "Split", "listener", "values", "push", "setResolve", "res", "rej", "noop", "nothing_default", "input", "isIterable", "result", "chunk", "A", "assign", "create", "BufferStream", "values", "assign", "create", "Stream", "output", "pipe", "value", "A", "nothing_default", "stop", "assign", "create", "PromiseStream", "promise", "Stream", "output", "pipe", "value", "stop", "assign", "create", "isActive", "object", "isStopped", "Pipe", "input", "name", "stream", "values", "pipes", "PromiseStream", "value", "stop", "CombineStream", "inputs", "options", "Stream", "output", "pipeable", "pipe", "assign", "create", "Source", "stream", "value", "stop", "stopable", "MergeStream", "inputs", "Stream", "output", "pipe", "source", "i", "input", "n", "assign", "create", "ClockStream", "duration", "Stream", "output", "pipe", "startTime", "fn", "time", "sendStopFrame", "stop", "assign", "create", "Throttle", "input", "duration", "Stream", "value", "clock", "ClockStream", "fn", "time", "sendLastValue", "assign", "create", "S", "Stream", "evaluate", "SignalStream", "signal", "initial", "hasInput", "n", "Signal", "output", "value", "pipe", "A", "assign", "throwTypeError", "source", "Stream", "object", "BufferStream", "PromiseStream", "SignalStream", "CombineStream", "path", "initial", "Data", "options", "Broadcast", "nothing_default", "duration", "ClockStream", "MergeStream", "time", "Throttle", "self", "frames", "assign", "rspaces", "types", "cacheByObject", "clickTimeStamp", "e", "listen", "listener", "type", "unlisten", "EventsProducer", "options", "node", "initialEvent", "output", "pipe", "selectedTarget", "stop", "events", "Stream", "runit", "parseValue", "units", "string", "entry", "to_rad_default", "n", "parse_angle_default", "parseValue", "to_rad_default", "id", "n", "string", "rpx", "rangle", "computedStyle", "name", "node", "style", "value", "parse_angle_default", "emSize", "remSize", "getEmSize", "styledFontSize", "style", "getRemSize", "px", "overload", "to_type_default", "id", "parseValue", "n", "parse_length_default", "A", "assign", "userSelect", "store", "config", "clickSuppressionTimestamp", "stopPropagation", "e", "distanceThreshold", "distance", "x", "y", "Pointermove", "stream", "options", "parse_length_default", "t", "overload", "get_default", "e0", "Stream", "output", "pipe", "stop", "isIgnoreTag", "tag", "PointerProducer", "node", "gestureTarget", "event", "gestures", "isPrimaryButton", "e", "windowBox", "rect", "node", "assign", "defaults", "trigger", "type", "node", "options", "properties", "detail", "bubbles", "cancelable", "composed", "event", "trigger_default", "curry_default", "$data", "config", "scrollInterval", "updateScrollInterval", "times", "n", "interval", "t", "getScrollInterval", "is_firefox_default", "DOMContentLoaded", "is_firefox_default", "e", "getPaddedBox", "slides", "box", "rect", "computed", "paddingLeft", "paddingRight", "px", "getSnapX", "element", "snap", "scrollToTarget", "target", "behavior", "slidesBox", "targetBox", "position", "scrollTo", "jumpTo", "getAligned", "elements", "leftPadding", "rightPadding", "centrePadding", "n", "slide", "slideRect", "detection", "isGhost", "getActive", "data", "children", "aligned", "updateActive", "current", "active", "activateIndex", "host", "activateNext", "i", "activatePrevious", "resetScroll", "slides", "scrolls", "processPointers", "overload", "data", "x1", "y1", "dx", "scrollLeft1", "scrollLeft2", "active", "getActive", "events", "frame", "e", "i", "stream", "getScrollInterval", "assign", "captureOptions", "fire", "producer", "times", "updateScrollInterval", "ScrollendsProducer", "element", "stream", "e", "time", "getScrollInterval", "stop", "scrollends", "Stream", "getWidth", "slides", "slot", "children", "n", "box", "rect", "right", "style", "pl", "px", "pr", "updateWidth", "width", "isSlide", "slide", "lifecycle_default", "shadow", "create_default", "controls", "connects", "Stream", "load", "slotchanges", "events", "e", "data", "mutations", "state", "equals_default", "views", "activations", "actives", "child", "trigger", "clicks", "isPrimaryButton", "scrolls", "scrollends", "$data", "nothing_default", "jumpTo", "scrollTo", "updateActive", "gestures", "pointers", "processPointers", "overload", "get_default", "noop", "createBoolean", "definition", "update", "element", "state", "value", "remove", "array", "value", "remove_default", "curry_default", "assign", "TokenList", "element", "definitions", "string", "n", "token", "remove", "A", "updateTokenList", "list", "tokens", "removes", "adds", "n", "createTokenList", "definitions", "$tokenlist", "update", "element", "string", "list", "TokenList", "updateTokenList", "value", "autoplay_exports", "__export", "disable", "enable", "getState", "parseTime", "parseValue", "id", "n", "change", "data", "active", "children", "elements", "host", "i", "target", "update", "style", "duration", "cancel", "enable", "$data", "actives", "autoplay", "hovers", "Stream", "events", "e", "focuses", "overload", "get_default", "v", "value", "state", "disable", "getState", "loop_exports", "__export", "disable", "enable", "getState", "toLoopGhost", "slide", "i", "ghost", "render", "data", "active", "children", "host", "slides", "loopOverflow", "boxes", "rect", "left", "right", "n", "appends", "prepends", "jumpTo", "enable", "$data", "mutations", "loop", "disable", "getState", "navigation_exports", "__export", "disable", "enable", "getState", "delegate", "object", "e", "target", "selector", "node", "update", "slides", "prev", "next", "elements", "i", "enable", "host", "data", "$data", "actives", "clicks", "slotchanges", "scrolls", "navigation", "create_default", "Stream", "state", "delegate", "node", "e", "activatePrevious", "activateNext", "button", "activateIndex", "disable", "getState", "pagination_exports", "__export", "disable", "enable", "getState", "update", "pagination", "children", "target", "active", "buttons", "index", "i", "render", "controls", "shadow", "create_default", "slide", "enable", "host", "data", "$data", "actives", "clicks", "mutations", "Stream", "state", "delegate", "button", "e", "disable", "getState", "fullscreen_exports", "__export", "disable", "enable", "getState", "fullscreenEnabled", "getFullscreenElement", "enterFullscreen", "node", "exitFullscreen", "enable", "host", "data", "$data", "fullscreenEnabled", "fullscreen", "create_default", "events", "e", "getFullscreenElement", "fullscreenend", "delegate", "target", "fullscreenCurrent", "exitFullscreen", "enterFullscreen", "disable", "getState", "properties_default", "id", "data", "$data", "child", "elements", "views", "active", "createBoolean", "autoplay_exports", "createTokenList", "navigation_exports", "pagination_exports", "fullscreen_exports", "loop_exports", "stylesheet", "module_default", "element", "lifecycle_default", "properties_default"]
}
